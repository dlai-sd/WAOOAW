"""
Agent Deployer - Full deployment pipeline

Handles:
1. DID provisioning
2. GitHub PR creation
3. Kubernetes deployment
4. Registry updates

Story: #83 Agent Deployer (3 pts)
Epic: #68 WowAgentFactory Core (v0.4.1)
Theme: CONCEIVE
"""

import logging
import subprocess
from typing import Any, Dict, Optional, List
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime

from waooaw.factory.config.schema import AgentSpecConfig
from waooaw.factory.registry import AgentRegistry, AgentMetadata, AgentStatus, AgentTier

logger = logging.getLogger(__name__)


# =============================================================================
# DATA CLASSES
# =============================================================================

@dataclass
class DeploymentResult:
    """Result of deployment operation"""
    success: bool
    agent_id: str
    did: Optional[str] = None
    pr_number: Optional[int] = None
    pr_url: Optional[str] = None
    k8s_deployment: Optional[str] = None
    errors: List[str] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.errors is None:
            self.errors = []


# =============================================================================
# DEPLOYMENT PIPELINE
# =============================================================================

class DeploymentPipeline:
    """
    Multi-stage deployment pipeline.
    
    Stages:
    1. Provision DID
    2. Create GitHub branch
    3. Commit code
    4. Create pull request
    5. Wait for approval
    6. Deploy to Kubernetes
    7. Update registry
    """
    
    def __init__(self, github_token: Optional[str] = None):
        """
        Initialize deployment pipeline.
        
        Args:
            github_token: GitHub API token (optional)
        """
        self.github_token = github_token
        self.registry = AgentRegistry()
        logger.info("‚úÖ DeploymentPipeline initialized")
    
    # =========================================================================
    # DID PROVISIONING
    # =========================================================================
    
    def provision_did(self, agent_id: str) -> str:
        """
        Provision decentralized identifier.
        
        Args:
            agent_id: Agent identifier
        
        Returns:
            DID string
        """
        logger.info(f"üÜî Provisioning DID for {agent_id}...")
        
        # Extract base name (remove 'Wow' prefix)
        base_name = agent_id[3:].lower() if agent_id.startswith("Wow") else agent_id.lower()
        
        # Generate DID
        did = f"did:waooaw:{base_name}"
        
        # TODO: Register in DID registry
        # TODO: Generate DID document
        # TODO: Store credentials
        
        logger.info(f"‚úÖ DID provisioned: {did}")
        return did
    
    # =========================================================================
    # GITHUB INTEGRATION
    # =========================================================================
    
    def create_branch(self, agent_id: str) -> str:
        """
        Create Git branch for agent.
        
        Args:
            agent_id: Agent identifier
        
        Returns:
            Branch name
        """
        branch_name = f"feature/agent-{agent_id.lower()}"
        
        try:
            # Create and checkout branch
            subprocess.run(
                ["git", "checkout", "-b", branch_name],
                check=True,
                capture_output=True
            )
            logger.info(f"üåø Created branch: {branch_name}")
            return branch_name
            
        except subprocess.CalledProcessError as e:
            logger.error(f"‚ùå Failed to create branch: {e}")
            # Try to checkout existing branch
            subprocess.run(["git", "checkout", branch_name])
            return branch_name
    
    def commit_files(
        self,
        files: List[Path],
        agent_id: str
    ) -> bool:
        """
        Commit generated files.
        
        Args:
            files: File paths to commit
            agent_id: Agent identifier
        
        Returns:
            True if successful
        """
        try:
            # Add files
            for file_path in files:
                subprocess.run(
                    ["git", "add", str(file_path)],
                    check=True
                )
            
            # Commit
            commit_msg = f"[WowAgentFactory] Add {agent_id}\n\nGenerated by WowAgentFactory"
            subprocess.run(
                ["git", "commit", "-m", commit_msg],
                check=True,
                capture_output=True
            )
            
            logger.info(f"üìù Committed {len(files)} files")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(f"‚ùå Failed to commit: {e}")
            return False
    
    def create_pull_request(
        self,
        agent_id: str,
        spec: AgentSpecConfig,
        branch_name: str
    ) -> Dict[str, Any]:
        """
        Create GitHub pull request.
        
        Args:
            agent_id: Agent identifier
            spec: Agent specification
            branch_name: Git branch name
        
        Returns:
            PR details
        """
        # TODO: Use GitHub API to create PR
        # For now, return placeholder
        
        pr_title = f"[WowAgentFactory] Add {agent_id}"
        pr_body = self._generate_pr_body(spec)
        
        pr_number = 999  # Placeholder
        pr_url = f"https://github.com/waooaw/platform/pull/{pr_number}"
        
        logger.info(f"üìù Created PR: {pr_url}")
        
        return {
            "number": pr_number,
            "url": pr_url,
            "title": pr_title,
            "body": pr_body,
            "branch": branch_name
        }
    
    def _generate_pr_body(self, spec: AgentSpecConfig) -> str:
        """Generate PR description"""
        capabilities_str = "\n".join([
            f"- {cat}: {', '.join(caps)}"
            for cat, caps in spec.capabilities.items()
        ])
        
        constraints_str = "\n".join([
            f"- {c['rule']}: {c['reason']}"
            for c in spec.constraints
        ]) if spec.constraints else "None"
        
        return f"""## New Platform CoE Agent: {spec.display_name}

**Tier:** {spec.tier}  
**Domain:** {spec.domain.value}  
**Version:** {spec.version}

### Description
{spec.description}

### Capabilities
{capabilities_str}

### Constraints
{constraints_str}

### Dependencies
{', '.join(spec.dependencies) if spec.dependencies else 'None'}

### Wake Patterns
{', '.join(spec.wake_patterns)}

### Resource Budget
${spec.resource_budget:.2f}/month

---

ü§ñ Generated by WowAgentFactory  
‚è∞ {datetime.now().isoformat()}  
üîç Awaiting WowVision Prime approval

## Checklist
- [ ] Code follows architecture principles
- [ ] Tests pass
- [ ] Documentation complete
- [ ] WowVision validation passed
- [ ] Dependencies available
"""
    
    # =========================================================================
    # KUBERNETES DEPLOYMENT
    # =========================================================================
    
    def deploy_to_k8s(
        self,
        agent_id: str,
        spec: AgentSpecConfig
    ) -> Optional[str]:
        """
        Deploy agent to Kubernetes.
        
        Args:
            agent_id: Agent identifier
            spec: Agent specification
        
        Returns:
            Deployment name or None if failed
        """
        logger.info(f"‚ò∏Ô∏è  Deploying {agent_id} to Kubernetes...")
        
        # Generate K8s manifests
        deployment_yaml = self._generate_k8s_deployment(agent_id, spec)
        service_yaml = self._generate_k8s_service(agent_id, spec)
        
        # TODO: Apply manifests using kubectl or K8s API
        # kubectl apply -f deployment.yaml
        # kubectl apply -f service.yaml
        
        deployment_name = f"{agent_id.lower()}-deployment"
        
        logger.info(f"‚úÖ Deployed: {deployment_name}")
        return deployment_name
    
    def _generate_k8s_deployment(
        self,
        agent_id: str,
        spec: AgentSpecConfig
    ) -> str:
        """Generate Kubernetes Deployment YAML"""
        return f"""apiVersion: apps/v1
kind: Deployment
metadata:
  name: {agent_id.lower()}-deployment
  namespace: waooaw
  labels:
    app: {agent_id.lower()}
    tier: tier-{spec.tier}
    domain: {spec.domain.value}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: {agent_id.lower()}
  template:
    metadata:
      labels:
        app: {agent_id.lower()}
    spec:
      containers:
      - name: {agent_id.lower()}
        image: waooaw/{agent_id.lower()}:latest
        ports:
        - containerPort: 8000
        env:
        - name: AGENT_ID
          value: "{agent_id}"
        - name: AGENT_DID
          value: "{spec.did if hasattr(spec, 'did') else 'TBD'}"
        - name: LOG_LEVEL
          value: "INFO"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
"""
    
    def _generate_k8s_service(
        self,
        agent_id: str,
        spec: AgentSpecConfig
    ) -> str:
        """Generate Kubernetes Service YAML"""
        return f"""apiVersion: v1
kind: Service
metadata:
  name: {agent_id.lower()}-service
  namespace: waooaw
spec:
  selector:
    app: {agent_id.lower()}
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
"""


# =============================================================================
# AGENT DEPLOYER
# =============================================================================

class AgentDeployer:
    """
    High-level agent deployment orchestrator.
    
    Combines all deployment steps into single operation.
    """
    
    def __init__(self, github_token: Optional[str] = None):
        """
        Initialize deployer.
        
        Args:
            github_token: GitHub API token
        """
        self.pipeline = DeploymentPipeline(github_token)
        self.registry = AgentRegistry()
        logger.info("‚úÖ AgentDeployer initialized")
    
    def deploy(
        self,
        agent_id: str,
        spec: AgentSpecConfig,
        files: List[Path],
        auto_approve: bool = False
    ) -> DeploymentResult:
        """
        Deploy agent through full pipeline.
        
        Args:
            agent_id: Agent identifier
            spec: Agent specification
            files: Generated files to commit
            auto_approve: Skip approval wait
        
        Returns:
            Deployment result
        """
        logger.info(f"üöÄ Deploying {agent_id}...")
        
        errors = []
        
        try:
            # Step 1: Provision DID
            did = self.pipeline.provision_did(agent_id)
            
            # Step 2: Create branch
            branch_name = self.pipeline.create_branch(agent_id)
            
            # Step 3: Commit files
            commit_success = self.pipeline.commit_files(files, agent_id)
            if not commit_success:
                errors.append("Failed to commit files")
            
            # Step 4: Create PR
            pr_info = self.pipeline.create_pull_request(agent_id, spec, branch_name)
            
            # Step 5: Wait for approval (unless auto_approve)
            if auto_approve:
                logger.info("‚ö° Auto-approve enabled, skipping wait")
            else:
                logger.info(f"‚è≥ Awaiting approval for PR #{pr_info['number']}")
                # In real implementation, would wait for PR approval
            
            # Step 6: Deploy to K8s (after approval)
            if auto_approve:
                k8s_deployment = self.pipeline.deploy_to_k8s(agent_id, spec)
                
                # Step 7: Update registry
                self.registry.update_status(agent_id, AgentStatus.ACTIVE)
                
                logger.info(f"‚úÖ Deployment complete: {agent_id}")
            else:
                k8s_deployment = None
                self.registry.update_status(agent_id, AgentStatus.PROVISIONED)
                logger.info(f"üìã Agent provisioned, awaiting approval: {agent_id}")
            
            return DeploymentResult(
                success=True,
                agent_id=agent_id,
                did=did,
                pr_number=pr_info["number"],
                pr_url=pr_info["url"],
                k8s_deployment=k8s_deployment,
                errors=errors
            )
            
        except Exception as e:
            logger.error(f"‚ùå Deployment failed: {e}")
            errors.append(str(e))
            
            return DeploymentResult(
                success=False,
                agent_id=agent_id,
                errors=errors
            )


# =============================================================================
# USAGE EXAMPLES
# =============================================================================

"""
Example: Using AgentDeployer

```python
from waooaw.factory.deployer import AgentDeployer
from waooaw.factory.config.schema import AgentSpecConfig, AgentDomain
from pathlib import Path

# Create spec
spec = AgentSpecConfig(
    coe_name="WowExample",
    display_name="WowExample",
    tier=3,
    domain=AgentDomain.COMMUNICATION,
    version="0.4.2",
    description="Example agent",
    capabilities={"messaging": ["send", "receive"]},
    dependencies=["WowAgentFactory"],
    wake_patterns=["example.*"],
    resource_budget=30.0
)

# Deploy
deployer = AgentDeployer(github_token="ghp_xxx")
files = [
    Path("waooaw/agents/wowexample.py"),
    Path("tests/factory/test_wowexample.py")
]

result = deployer.deploy(
    agent_id="WowExample",
    spec=spec,
    files=files,
    auto_approve=False  # Wait for WowVision approval
)

if result.success:
    print(f"‚úÖ Deployed: {result.pr_url}")
else:
    print(f"‚ùå Failed: {result.errors}")
```
"""
