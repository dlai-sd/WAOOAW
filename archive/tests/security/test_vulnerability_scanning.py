"""
Security Tests - Vulnerability Scanning

Tests for common vulnerabilities and security best practices.
"""
import pytest
import sys
import os
import tempfile
import yaml
sys.path.insert(0, '/workspaces/WAOOAW')


class TestDependencyVulnerabilities:
    """Test for vulnerable dependencies."""
    
    def test_no_known_vulnerable_packages(self):
        """Test: Check requirements for known vulnerabilities."""
        # Read requirements.txt
        req_file = "/workspaces/WAOOAW/backend/requirements.txt"
        
        if os.path.exists(req_file):
            with open(req_file, 'r') as f:
                requirements = f.read()
            
            # Known vulnerable packages to avoid (examples)
            vulnerable_patterns = [
                "pyyaml<5.4",  # YAML load vulnerability
                "jinja2<2.11.3",  # XSS vulnerability
                "urllib3<1.26.5",  # Multiple vulnerabilities
            ]
            
            for pattern in vulnerable_patterns:
                pkg_name = pattern.split('<')[0]
                assert pkg_name not in requirements.lower() or pattern not in requirements, \
                    f"Potentially vulnerable package pattern: {pattern}"
    
    def test_dependency_pinning(self):
        """Test: Dependencies are pinned to specific versions."""
        req_file = "/workspaces/WAOOAW/backend/requirements.txt"
        
        if os.path.exists(req_file):
            with open(req_file, 'r') as f:
                lines = f.readlines()
            
            unpinned = []
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    # Check if version is specified
                    if '==' not in line and '>=' not in line and '~=' not in line:
                        unpinned.append(line)
            
            # Some unpinned dependencies might be okay, but generally should be pinned
            # For production, we want specific versions
            assert len(unpinned) < 5, f"Many unpinned dependencies: {unpinned}"


class TestConfigurationSecurity:
    """Test secure configuration practices."""
    
    def test_no_hardcoded_secrets(self):
        """Test: No secrets hardcoded in config files."""
        config_dir = "/workspaces/WAOOAW/waooaw/config"
        
        if os.path.exists(config_dir):
            for filename in os.listdir(config_dir):
                if filename.endswith('.yaml') or filename.endswith('.yml'):
                    filepath = os.path.join(config_dir, filename)
                    with open(filepath, 'r') as f:
                        content = f.read()
                    
                    # Check for patterns that look like secrets
                    suspicious_patterns = [
                        "password: ",
                        "api_key: ",
                        "secret: ",
                        "token: "
                    ]
                    
                    for pattern in suspicious_patterns:
                        if pattern in content.lower():
                            # Check if it's a placeholder or reference
                            lines = content.split('\n')
                            for line in lines:
                                if pattern in line.lower():
                                    # Should use env vars or placeholders
                                    assert (
                                        "${" in line or
                                        "ENV[" in line or
                                        "null" in line or
                                        "~" in line or
                                        "#" in line  # Comment
                                    ), f"Possible hardcoded secret in {filename}: {line}"
    
    def test_secure_default_settings(self):
        """Test: Default settings are secure."""
        config_content = """
production:
  debug: false
  ssl_enabled: true
  log_level: INFO
"""
        
        config = yaml.safe_load(config_content)
        
        # Production should have secure defaults
        if 'production' in config:
            prod_config = config['production']
            
            # Debug should be off in production
            if 'debug' in prod_config:
                assert prod_config['debug'] is False
            
            # SSL should be enabled
            if 'ssl_enabled' in prod_config:
                assert prod_config['ssl_enabled'] is True
    
    def test_file_permissions(self):
        """Test: Sensitive files have proper permissions."""
        import stat
        
        # Check if secrets or config files exist
        sensitive_files = [
            "/workspaces/WAOOAW/waooaw/config/agent_config.yaml",
        ]
        
        for filepath in sensitive_files:
            if os.path.exists(filepath):
                # Get file permissions
                file_stat = os.stat(filepath)
                mode = file_stat.st_mode
                
                # Check world-readable bit (should not be world-writable)
                is_world_writable = bool(mode & stat.S_IWOTH)
                assert not is_world_writable, f"File is world-writable: {filepath}"


class TestCodeSecurity:
    """Test code security practices."""
    
    def test_no_eval_usage(self):
        """Test: Code doesn't use dangerous eval()."""
        # Search for eval usage in Python files
        code_dirs = [
            "/workspaces/WAOOAW/waooaw",
        ]
        
        dangerous_functions = ['eval(', 'exec(']
        
        for code_dir in code_dirs:
            if os.path.exists(code_dir):
                for root, dirs, files in os.walk(code_dir):
                    for file in files:
                        if file.endswith('.py'):
                            filepath = os.path.join(root, file)
                            with open(filepath, 'r') as f:
                                try:
                                    content = f.read()
                                    for dangerous in dangerous_functions:
                                        if dangerous in content:
                                            # Check if it's in a comment
                                            for line in content.split('\n'):
                                                if dangerous in line and not line.strip().startswith('#'):
                                                    # Allow in specific test contexts
                                                    if 'test' not in filepath and 'example' not in filepath:
                                                        assert False, f"Dangerous function {dangerous} found in {filepath}"
                                except Exception:
                                    pass  # Skip files that can't be read
    
    def test_safe_yaml_loading(self):
        """Test: YAML is loaded safely."""
        # Check for safe_load usage instead of load
        dangerous_content = """
import yaml
data = yaml.load(user_input)  # DANGEROUS
"""
        
        safe_content = """
import yaml
data = yaml.safe_load(user_input)  # SAFE
"""
        
        # Test that safe_load works
        test_yaml = "key: value"
        data = yaml.safe_load(test_yaml)
        assert data == {"key": "value"}
        
        # Demonstrate unsafe yaml.load could execute code (but we don't actually do it)
        # This test just ensures we know the difference
        assert hasattr(yaml, 'safe_load'), "yaml.safe_load should be available"
    
    def test_no_shell_injection(self):
        """Test: No shell command injection vulnerabilities."""
        import subprocess
        
        # UNSAFE: shell=True with user input
        # subprocess.run(f"ls {user_input}", shell=True)  # DANGEROUS
        
        # SAFE: Use list without shell
        result = subprocess.run(["echo", "safe"], capture_output=True)
        assert result.returncode == 0
        
        # Demonstrate safe practices
        user_input = "test; rm -rf /"  # Malicious input
        
        # Safe way - input is treated as data, not code
        result = subprocess.run(["echo", user_input], capture_output=True, text=True)
        assert "rm -rf" in result.stdout  # It's echoed as data, not executed


class TestErrorHandling:
    """Test secure error handling."""
    
    def test_no_sensitive_info_in_errors(self):
        """Test: Error messages don't expose sensitive info."""
        from waooaw.common.config_manager import ConfigManager
        
        # Try to load non-existent config
        try:
            config = ConfigManager(
                config_file="/nonexistent/path/config.yaml",
                environment="test"
            )
            config.get("some.key")
        except Exception as e:
            error_msg = str(e)
            
            # Error should not expose:
            # - Full system paths
            # - Database connection strings
            # - API keys
            # - Internal implementation details
            
            # These checks are examples
            assert "/home/" not in error_msg or "nonexistent" in error_msg  # Generic paths OK
            assert "password" not in error_msg.lower()
            assert "secret" not in error_msg.lower()
    
    def test_stack_traces_sanitized(self):
        """Test: Stack traces don't expose sensitive data."""
        import traceback
        
        try:
            api_key = "super_secret_key_12345"
            # Simulate an error
            raise ValueError("Connection failed")
        except Exception:
            tb = traceback.format_exc()
            
            # Stack trace should not contain secrets
            # (In this case it might be in local vars, so be careful)
            # In production, we should sanitize tracebacks
            assert True  # This is a reminder to sanitize in production


class TestNetworkSecurity:
    """Test network security practices."""
    
    def test_https_enforcement(self):
        """Test: HTTPS is enforced for external calls."""
        import re
        
        # URLs should use HTTPS
        test_urls = [
            "https://api.github.com",
            "https://api.anthropic.com"
        ]
        
        for url in test_urls:
            assert url.startswith("https://"), f"URL not using HTTPS: {url}"
    
    def test_certificate_validation(self):
        """Test: SSL certificate validation is enabled."""
        import urllib3
        
        # Ensure warnings are enabled (not disabled)
        # In production, never disable SSL warnings
        # urllib3.disable_warnings()  # NEVER DO THIS
        
        # Certificate validation should be on by default
        assert True  # Placeholder - would test actual HTTP client config
    
    def test_timeout_configuration(self):
        """Test: Network requests have timeouts."""
        import asyncio
        
        async def request_with_timeout():
            try:
                # Simulate network request with timeout
                await asyncio.wait_for(
                    asyncio.sleep(10),
                    timeout=5.0
                )
            except asyncio.TimeoutError:
                return "Timeout worked"
        
        # Run with timeout
        result = asyncio.run(request_with_timeout())
        assert result == "Timeout worked"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
