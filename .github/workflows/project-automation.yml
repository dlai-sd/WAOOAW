name: GitHub Project Automation

on:
  issues:
    types: [opened, labeled, closed, reopened]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, closed, reopened]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  auto-triage:
    name: Auto-Triage Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    steps:
      - name: Add to project board
        if: vars.PROJECT_URL != ''
        uses: actions/add-to-project@v0.5.0
        with:
          project-url: ${{ vars.PROJECT_URL }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set agent owner based on labels
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);

            // Auto-assign based on label
            let assignee = null;
            if (labels.includes('epic')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['vision-guardian-agent']
              });
              core.info('Epic issue - assigned to Vision Guardian Agent');

              // Create Vision Guardian Review Issue with Agent Task
              const epicTitle = issue.title;
              const epicNumber = issue.number;
              const epicBody = issue.body || '';

              const reviewBody = '## Vision Guardian Agent Task\n\n' +
                '**Epic**: #' + epicNumber + ' - ' + epicTitle + '\n\n' +
                '---\n\n' +
                '## Agent Instructions\n\n' +
                '@github-copilot You are the **Vision Guardian Agent** (GOV-002). ' +
                'Analyze this epic and provide comprehensive constitutional review.\n\n' +
                '### Your Task:\n\n' +
                '1. Read Epic #' + epicNumber + '\n' +
                '2. Analyze against /main/Foundation.md, /docs/BRAND_STRATEGY.md\n' +
                '3. Identify gaps (business, technical, vision, risk)\n' +
                '4. Propose world-class solutions\n' +
                '5. Calculate alignment score (0-100)\n' +
                '6. Assign risk level (1-4)\n' +
                '7. Post comprehensive review\n\n' +
                '### Required Analysis:\n\n' +
                '- Constitutional alignment check\n' +
                '- Gap analysis with specific solutions\n' +
                '- Risk assessment\n' +
                '- Recommendation: Approve/Revise/Reject\n\n' +
                '---\n\n' +
                '## Epic Details\n\n' +
                epicBody + '\n\n' +
                '---\n\n' +
                '**Status**: Waiting for Vision Guardian analysis\n\n' +
                '**Instructions**: Vision Guardian will post review below. ' +
                'Governor reviews and comments decision.\n\n' +
                '**Related Epic**: #' + epicNumber;

              const review = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '[VG REVIEW] Epic #' + epicNumber + ': ' + epicTitle,
                body: reviewBody,
                labels: ['vision-guardian-agent', 'vision-guardian-review', '#github-pull-request_copilot-coding-agent']
              });

              core.info(`Created Vision Guardian review issue #${review.data.number}`);

              // Comment on epic with link to review
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: `üõ°Ô∏è **Vision Guardian Review Created**: #${review.data.number}\n\nPlease complete the constitutional review before proceeding with implementation.`
              });

            } else if (labels.includes('story')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['business-analyst-agent']
              });
              core.info('Story issue - assigned to Business Analyst Agent');
            } else if (labels.includes('task')) {
              const taskType = issue.body.match(/Task Type.*?\n.*?- \[(.*?)\]/s);
              if (taskType && taskType[1].includes('Infrastructure')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['deployment-agent']
                });
              } else if (taskType && taskType[1].includes('Testing')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['testing-agent']
                });
              } else {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['systems-architect-agent']
                });
              }
              core.info('Task issue - assigned based on task type');
            } else if (labels.includes('bug')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['testing-agent']
              });
              core.info('Bug issue - assigned to Testing Agent for triage');
            }

  move-to-in-progress:
    name: Move to In Progress
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'in-progress'
    steps:
      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: 'üöÄ **Status Update**: Issue moved to **In Progress**\n\nAgent working on implementation...'
            });

  move-to-review:
    name: Move to Review
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'in-review'
    steps:
      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: 'üëÄ **Status Update**: Issue moved to **Review**\n\nAwaiting validation and approval...'
            });

  move-to-done:
    name: Move to Done
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'closed'
    steps:
      - name: Add completion comment
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['done']
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: '‚úÖ **Status Update**: Issue moved to **Done**\n\nWork completed and closed.'
            });

  link-pr-to-issue:
    name: Link PR to Issue
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    steps:
      - name: Auto-link PR to issue
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';

            // Extract issue numbers from PR body (Closes #123, Fixes #456)
            const issuePattern = /(Closes|Fixes|Resolves)\s+#(\d+)/gi;
            const matches = [...prBody.matchAll(issuePattern)];

            if (matches.length > 0) {
              for (const match of matches) {
                const issueNumber = match[2];
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  body: `üîó **PR Linked**: #${pr.number} - ${pr.title}\n\nImplementation in progress...`
                });

                // Add in-review label to issue
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  labels: ['in-review']
                });
              }
            }

  auto-close-issue-on-pr-merge:
    name: Auto-Close Issue on PR Merge
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    steps:
      - name: Close linked issues
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';

            // Extract issue numbers from PR body
            const issuePattern = /(Closes|Fixes|Resolves)\s+#(\d+)/gi;
            const matches = [...prBody.matchAll(issuePattern)];

            if (matches.length > 0) {
              for (const match of matches) {
                const issueNumber = match[2];

                // Close the issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  state: 'closed'
                });

                // Add completion comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  body: `‚úÖ **Closed via PR**: #${pr.number}\n\n**Merged by**: @${pr.merged_by.login}\n**Deployed**: Changes will be deployed in next release.`
                });
              }
            }

  autonomous-vg-analysis:
    name: Autonomous VG Analysis
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      (github.event.action == 'opened' || github.event.action == 'labeled') &&
      contains(github.event.issue.labels.*.name, 'vision-guardian-review')
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger Copilot Coding Agent for VG Analysis (Chunked)
        uses: actions/github-script@v7
        with:
          script: |
            const reviewIssue = context.payload.issue;
            const issueBody = reviewIssue.body || '';
            const epicMatch = issueBody.match(/\*\*Epic\*\*:\s+#(\d+)/);

            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }

            const epicNumber = epicMatch[1];

            // Get epic details
            const epic = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(epicNumber)
            });

            const epicTitle = epic.data.title;
            const epicBody = epic.data.body || '';

            // Helper function to post comments with rate limit protection
            async function postChunkedComment(body, delayMs = 500) {
              try {
                const response = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: reviewIssue.number,
                  body: body
                });
                core.info(`Comment posted: ${response.data.id}`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
                return response;
              } catch (error) {
                if (error.status === 403 && error.message.includes('rate limit')) {
                  const resetTime = error.response?.headers?.['x-ratelimit-reset'] || 0;
                  const waitMs = Math.max((resetTime * 1000) - Date.now(), 60000);
                  core.warning(`Rate limited. Waiting ${waitMs}ms...`);
                  await new Promise(resolve => setTimeout(resolve, waitMs));
                  return postChunkedComment(body, delayMs);
                }
                throw error;
              }
            }

            // Chunked VG Analysis (7 parts to avoid GitHub API 65k char limit)
            // Ref: /main/Foundation/AUTONOMOUS_AGENT_OPERATIONAL_GUIDELINES.md

            const section1 = "## ü§ñ Autonomous VG Analysis - Part 1/7: Overview\n\n" +
              `**Triggered by**: \`vision-guardian-review\` label\n` +
              `**Epic**: #${epicNumber} - ${epicTitle}\n` +
              `**Charter**: [vision_guardian_agent_charter.md v2.0](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/main/Foundation/vision_guardian_agent_charter.md)\n\n` +
              "@github-copilot I am the **Vision Guardian Agent (GOV-002)** operating autonomously.\n\n" +
              "### Epic Content\n```\n" +
              `${epicBody.length > 2000 ? epicBody.substring(0, 2000) + '...[truncated]' : epicBody}\n` +
              "```\n\n" +
              "### Required Documents\n" +
              `- [Foundation.md](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/main/Foundation.md) (L0 Constitution - 824 lines)\n` +
              `- [BRAND_STRATEGY.md](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/docs/BRAND_STRATEGY.md) (Brand DNA)\n` +
              `- [Vision Guardian Charter v2.0](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/main/Foundation/vision_guardian_agent_charter.md) (394 lines)\n\n` +
              "---\n\n" +
              "**Next**: Part 2/7 will request Business Impact Analysis";

            const section2 = "## ü§ñ Autonomous VG Analysis - Part 2/7: Business Impact\n\n" +
              `@github-copilot Please provide **Business Impact Analysis** for Epic #${epicNumber}:\n\n` +
              "### Required Analysis\n" +
              "- **Revenue Impact**: ‚Çπ[amount]/month (direct + indirect)\n" +
              "- **Market Position**: Competitive advantage, differentiation\n" +
              "- **Customer Acquisition**: Expected conversion rate\n" +
              "- **Retention Impact**: Churn rate effect\n" +
              "- **Time to Market**: Speed advantage vs competitors\n" +
              "- **Strategic Value**: Long-term positioning\n\n" +
              "### Format\n" +
              "Use quantitative estimates (numbers, percentages, currency) wherever possible. Reference specific market data or assumptions.\n\n" +
              "---\n\n" +
              "**Next**: Part 3/7 will request Constitutional Alignment Check";

            const section3 = "## ü§ñ Autonomous VG Analysis - Part 3/7: Constitutional Alignment\n\n" +
              `@github-copilot Please perform **Constitutional Alignment Check** for Epic #${epicNumber}:\n\n` +
              "### Check Each Core Principle\n" +
              "- **L0 Constitution** (Foundation.md): Pass/Fail with specific findings\n" +
              "- **\"Agents Earn Your Business\"** philosophy: Try-before-hire, keep deliverables\n" +
              "- **Deny-by-Default Security**: Security posture maintained?\n" +
              "- **Marketplace DNA**: Browse, compare, discover agents like talent\n" +
              "- **Agentic Vibe**: Personality, status, specializations preserved?\n\n" +
              "### Scoring\n" +
              "- L0 Constitution (40 pts)\n" +
              "- L1 Canonical Model (20 pts)\n" +
              "- L2 Operations (20 pts)\n" +
              "- L3 Learning (10 pts)\n" +
              "- Brand DNA (10 pts)\n\n" +
              "---\n\n" +
              "**Next**: Part 4/7 will request Gap Analysis";

            const section4 = "## ü§ñ Autonomous VG Analysis - Part 4/7: Gap Analysis\n\n" +
              `@github-copilot Please identify **ALL gaps** in Epic #${epicNumber}:\n\n` +
              "### Gap Categories (use P0/P1/P2 priority)\n\n" +
              "**Business Value Gaps**:\n" +
              "- Missing: [description]\n" +
              "- **Recommendation**: [specific solution]\n" +
              "- **Rationale**: [why this matters]\n" +
              "- **Implementation**: [how to fix]\n\n" +
              "**Technical Gaps**:\n" +
              "- Architecture considerations\n" +
              "- Dependencies, performance, security\n\n" +
              "**Vision Gaps**:\n" +
              "- Alignment with product vision\n" +
              "- Long-term strategy\n\n" +
              "**Risk Gaps**:\n" +
              "- Missing risk assessments\n" +
              "- Mitigation strategies\n\n" +
              "**Scope Gaps**:\n" +
              "- Unclear boundaries\n" +
              "- Success criteria\n\n" +
              "### Format\n" +
              "For each gap: Description + Priority + Specific solution + Implementation steps\n\n" +
              "---\n\n" +
              "**Next**: Part 5/7 will request Precedent Search";

            const section5 = "## ü§ñ Autonomous VG Analysis - Part 5/7: Precedent Search\n\n" +
              `@github-copilot Please search for **Precedents** related to Epic #${epicNumber}:\n\n` +
              "### Search Locations\n" +
              "- /main/Foundation/precedents/*.md\n" +
              "- Past epics with similar scope\n" +
              "- Existing ADRs\n\n" +
              "### Report\n" +
              "- **Applicable Precedents**: PREC-VG-[IDs]\n" +
              "- **Pattern Applied**: [description]\n" +
              "- **Lessons Learned**: Success factors, pitfalls\n" +
              "- **Reusable Components**: Architecture patterns, design patterns\n" +
              "- **Conflicts**: Any contradictions with past decisions\n\n" +
              "---\n\n" +
              "**Next**: Part 6/7 will request Risk Quantification";

            const section6 = "## ü§ñ Autonomous VG Analysis - Part 6/7: Risk Quantification\n\n" +
              `@github-copilot Please quantify **ALL risks** for Epic #${epicNumber}:\n\n` +
              "### Risk Categories (use numbers)\n\n" +
              "**Financial Risk**:\n" +
              "- Potential loss: ‚Çπ[amount]\n" +
              "- Development cost overrun: [%]\n\n" +
              "**Customer Impact**:\n" +
              "- Users affected: [X] customers\n" +
              "- Churn probability: [Y]%\n\n" +
              "**Security Risk**:\n" +
              "- Breach cost: ‚Çπ[amount]\n" +
              "- Data exposure: [count] records\n\n" +
              "**Compliance Risk**:\n" +
              "- Regulatory fine potential: ‚Çπ[amount]\n\n" +
              "**Reputation Risk**:\n" +
              "- NPS drop estimate: [points]\n" +
              "- Media mentions: [count]\n\n" +
              "**Recovery Cost**:\n" +
              "- Rollback time: [hours]\n" +
              "- Rollback cost: ‚Çπ[amount]\n\n" +
              "### Risk Level\n" +
              "- **Overall**: 1-4 (Auto-block | Escalate | Approve with conditions | Fast-track)\n\n" +
              "---\n\n" +
              "**Next**: Part 7/7 will provide Final Recommendation";

            const section7 = "## ü§ñ Autonomous VG Analysis - Part 7/7: Final Recommendation\n\n" +
              `@github-copilot Please provide your **Final Recommendation** for Epic #${epicNumber}:\n\n` +
              "### Decision (choose ONE)\n" +
              "- ‚úÖ **APPROVE**: Fully aligned, ready to proceed\n" +
              "- ‚ö†Ô∏è **APPROVE_WITH_CONDITIONS**: Aligned but needs minor adjustments\n" +
              "- üîÑ **REVISE**: Significant gaps, needs rework\n" +
              "- ‚ùå **REJECT**: Fundamentally misaligned\n\n" +
              "### Alignment Score Format\n" +
              "**CRITICAL**: Use this exact format for automation:\n\n" +
              "```\n" +
              "**Alignment Score**: X/100\n\n" +
              "**Decision**: [APPROVE | APPROVE_WITH_CONDITIONS | REVISE | REJECT]\n" +
              "```\n\n" +
              "### Scoring Breakdown\n" +
              "- Constitutional Alignment (0-40 points)\n" +
              "- Business Case Strength (0-30 points)\n" +
              "- Completeness (0-20 points)\n" +
              "- Risk Management (0-10 points)\n\n" +
              "### Conditions (if APPROVE_WITH_CONDITIONS)\n" +
              "1. [Specific condition with acceptance criteria]\n" +
              "2. [Specific condition with acceptance criteria]\n\n" +
              "### Required Changes (if REVISE)\n" +
              "1. [Specific change with definition of done]\n" +
              "2. [Specific change with definition of done]\n\n" +
              "### Justification\n" +
              "[2-3 sentences explaining decision]\n\n" +
              "### Next Steps\n" +
              "- [Action items for Governor/Systems Architect/BA]\n\n" +
              "---\n\n" +
              "### üéØ Auto-Approval Threshold\n" +
              "- Score ‚â• 80/100 AND Decision = APPROVE or APPROVE_WITH_CONDITIONS\n" +
              "- System will automatically create epic branch and trigger BA/SA\n\n" +
              "### Escalation (if needed)\n" +
              `If score < 80 or Decision = REVISE/REJECT, use ` +
              `[3-solution escalation format](https://github.com/${context.repo.owner}/` +
              `${context.repo.repo}/blob/main/main/Foundation/AUTONOMOUS_AGENT_OPERATIONAL_GUIDELINES.md#escalation-rules).\n\n` +
              "---\n\n" +
              "**VG Agent**: Complete analysis using the format above. Your Decision and Alignment Score will trigger automated processing.";

            // Post all 7 sections with rate limit protection (500ms delay)
            core.info('Posting VG analysis in 7 chunked sections (30k char threshold)...');
            await postChunkedComment(section1);
            await postChunkedComment(section2);
            await postChunkedComment(section3);
            await postChunkedComment(section4);
            await postChunkedComment(section5);
            await postChunkedComment(section6);
            await postChunkedComment(section7);
            core.info('‚úÖ All 7 sections posted successfully. Character limit protection active.');

            core.info(`Autonomous VG analysis triggered for Epic #${epicNumber}`);

  vg-approval-handler:
    name: VG Approval Handler
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.action == 'created' &&
      contains(github.event.issue.labels.*.name, 'vision-guardian-review')
    permissions:
      issues: write
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Handle Governor Decision or Auto-Approve
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const commentLower = comment.toLowerCase().trim();
            const reviewIssue = context.payload.issue;
            const issueBody = reviewIssue.body || '';
            const epicMatch = issueBody.match(/\*\*Epic\*\*:\s+#(\d+)/);

            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }

            const epicNumber = epicMatch[1];
            const epic = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(epicNumber)
            });

            const epicTitle = epic.data.title;
            const branchSlug = epicTitle.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').substring(0, 50);
            const branchName = 'epic-' + epicNumber + '-' + branchSlug;

            // Check if this is VG Agent's analysis (auto-approve logic)
            const isVGAnalysis = comment.includes('## Vision Guardian Constitutional Review') ||
                                 comment.includes('**VG Agent**:');

            if (isVGAnalysis) {
              // Extract alignment score
              const scoreMatch = comment.match(/\*\*Alignment Score\*\*:\s*(\d+)\/100/);
              const score = scoreMatch ? parseInt(scoreMatch[1]) : 0;

              // Extract recommendation
              const recommendMatch = comment.match(/\*\*Decision\*\*:\s*(APPROVE|APPROVE_WITH_CONDITIONS|REVISE|REJECT)/i);
              const recommendation = recommendMatch ? recommendMatch[1].toUpperCase() : 'REVISE';

              core.info(`VG Analysis detected - Score: ${score}, Recommendation: ${recommendation}`);

              // Auto-approve if score >= 80 AND recommendation is APPROVE or APPROVE_WITH_CONDITIONS
              if ((recommendation === 'APPROVE' || recommendation === 'APPROVE_WITH_CONDITIONS') && score >= 80) {
                core.info('Auto-approving based on VG analysis (score >= 80)');

                // Create epic branch
                const defaultBranch = await github.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                const mainRef = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/' + defaultBranch.data.default_branch
                });

                try {
                  await github.rest.git.createRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: 'refs/heads/' + branchName,
                    sha: mainRef.data.object.sha
                  });
                  core.info(`Created branch: ${branchName}`);
                } catch (error) {
                  if (error.status !== 422) throw error;
                  core.info(`Branch ${branchName} already exists`);
                }

                // Notify epic
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(epicNumber),
                  body: `‚úÖ **Vision Guardian Approved (Autonomous)**\n\n` +
                        `**Alignment Score**: ${score}/100\n` +
                        `**Decision**: ${recommendation}\n` +
                        `**Branch**: \`${branchName}\`\n\n` +
                        `ü§ñ **Autonomous Workflow Active**:\n` +
                        `1. ‚úÖ Vision Guardian - Constitutional review complete\n` +
                        `2. üîÑ Business Analyst - Creating user stories (next)\n` +
                        `3. ‚è≥ Systems Architect - Architecture design (parallel with BA)\n` +
                        `4. ‚è≥ Coding Agent - Implementation (after BA+SA)\n` +
                        `5. ‚è≥ Testing Agent - Validation (after Coding)\n` +
                        `6. ‚è≥ Deployment Agent - Production (after Testing)\n\n` +
                        `**Systems Architect & Business Analyst notified.**`
                });

                // Add labels to epic for BA and SA to pick up
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(epicNumber),
                  labels: ['vg-approved', 'business-analyst', 'systems-architect']
                });

                // Close VG review issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: reviewIssue.number,
                  state: 'closed',
                  state_reason: 'completed'
                });

                return;
              } else {
                // Requires Governor manual review
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: reviewIssue.number,
                  body: `‚ö†Ô∏è **Autonomous Approval Threshold Not Met**\n\n` +
                        `**Score**: ${score}/100 (requires >= 80)\n` +
                        `**Recommendation**: ${recommendation}\n\n` +
                        `@${context.repo.owner} **Governor manual review required.**\n\n` +
                        `Comment \`approve\` to proceed or \`reject\` to decline.`
                });

                return;
              }
            }

            // Manual Governor approval/rejection
            if (commentLower === 'approve' || commentLower.startsWith('approve')) {
              core.info('Governor manually approved epic');
              const defaultBranch = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              const mainRef = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/' + defaultBranch.data.default_branch
              });
              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'refs/heads/' + branchName,
                  sha: mainRef.data.object.sha
                });
              } catch (error) {
                if (error.status !== 422) throw error;
              }
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(epicNumber),
                body: `‚úÖ **Vision Guardian Approved (Manual Override)**\n\nBranch: \`${branchName}\`\n\nSystems Architect & Business Analyst notified.`
              });
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(epicNumber),
                labels: ['vg-approved', 'business-analyst', 'systems-architect']
              });
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: reviewIssue.number,
                state: 'closed'
              });
            } else if (commentLower === 'reject' || commentLower.startsWith('reject')) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(epicNumber),
                state: 'closed',
                state_reason: 'not_planned'
              });
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: reviewIssue.number,
                state: 'closed'
              });
            }

  auto-commit-docs:
    name: Auto-Commit Docs from Issues
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'closed' &&
      (contains(github.event.issue.labels.*.name, 'vision-guardian-review') ||
       contains(github.event.issue.labels.*.name, 'architect-analysis') ||
       contains(github.event.issue.labels.*.name, 'user-story') ||
       contains(github.event.issue.labels.*.name, 'test-plan'))
    permissions:
      contents: write
      issues: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract and commit documentation
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const issueTitle = issue.title;
            const issueNumber = issue.number;
            const labels = issue.labels.map(l => l.name);

            let epicNumber = null;
            let docPath = null;
            let docContent = '';

            if (labels.includes('vision-guardian-review')) {
              const epicMatch = issueBody.match(/\*\*Epic\*\*:\s+#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1];
              docPath = `docs/epics/${epicNumber}/vision-review.md`;
              docContent = `# Vision Guardian Review\n\n` +
                `**Epic**: #${epicNumber}\n` +
                `**Review Issue**: #${issueNumber}\n` +
                `**Date**: ${new Date().toISOString().split('T')[0]}\n\n` +
                `---\n\n${issueBody}\n`;
            } else if (labels.includes('architect-analysis')) {
              const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1] || epicMatch[2];
              const analysisType = issueTitle.toLowerCase().includes('cost') ? 'cost-analysis' :
                                   issueTitle.toLowerCase().includes('compliance') ? 'compliance-check' :
                                   issueTitle.toLowerCase().includes('simulation') ? 'simulation-results' :
                                   'gap-analysis';
              docPath = `docs/epics/${epicNumber}/architecture/${analysisType}.md`;
              docContent = `# ${issueTitle}\n\n` +
                `**Epic**: #${epicNumber}\n` +
                `**Analysis Issue**: #${issueNumber}\n\n` +
                `---\n\n${issueBody}\n`;
            } else if (labels.includes('user-story')) {
              const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1] || epicMatch[2];
              docPath = `docs/epics/${epicNumber}/user-stories/${issueNumber}-story.md`;
              docContent = `# User Story: ${issueTitle}\n\n` +
                `**Story Issue**: #${issueNumber}\n\n` +
                `---\n\n${issueBody}\n`;
            } else if (labels.includes('test-plan')) {
              const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1] || epicMatch[2];
              docPath = `docs/epics/${epicNumber}/test-plans/${issueNumber}-test-plan.md`;
              docContent = `# Test Plan: ${issueTitle}\n\n` +
                `**Test Issue**: #${issueNumber}\n\n` +
                `---\n\n${issueBody}\n`;
            }

            if (!docPath || !epicNumber) {
              core.info('No doc path determined');
              return;
            }

            const branches = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const epicBranch = branches.data.find(b => b.name.startsWith('epic-' + epicNumber));
            if (!epicBranch) {
              core.warning('Epic branch not found for epic #' + epicNumber);
              return;
            }

            core.info('Committing to branch: ' + epicBranch.name);

            const fs = require('fs');
            const path = require('path');
            const dirPath = path.dirname(docPath);

            await exec.exec('git', ['config', 'user.name', 'github-actions[bot]']);
            await exec.exec('git', ['config', 'user.email', 'github-actions[bot]@users.noreply.github.com']);
            await exec.exec('git', ['fetch', 'origin', epicBranch.name]);
            await exec.exec('git', ['checkout', epicBranch.name]);
            await exec.exec('mkdir', ['-p', dirPath]);

            fs.writeFileSync(docPath, docContent);

            await exec.exec('git', ['add', docPath]);
            await exec.exec('git', ['commit', '-m', `docs: archive issue #${issueNumber} to ${docPath}`]);
            await exec.exec('git', ['push', 'origin', epicBranch.name]);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `üìù **Documentation Archived**\n\nCommitted to: \`${docPath}\` on branch \`${epicBranch.name}\``
            });

  autonomous-ba-sa-trigger:
    name: Autonomous BA & SA Trigger
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'labeled' &&
      (github.event.label.name == 'business-analyst' || github.event.label.name == 'systems-architect')
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger Autonomous BA and SA Analysis
        uses: actions/github-script@v7
        with:
          script: |
            const epic = context.payload.issue;
            const epicNumber = epic.number;
            const epicTitle = epic.title;
            const epicBody = epic.body || '';
            const label = context.payload.label.name;

            // Rate limit helper (reuse from VG)
            async function postChunkedComment(body, delayMs = 500) {
              try {
                const response = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: epicNumber,
                  body: body
                });
                core.info(`Comment posted: ${response.data.id}`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
                return response;
              } catch (error) {
                if (error.status === 403 && error.message.includes('rate limit')) {
                  const resetTime = error.response?.headers?.['x-ratelimit-reset'] || 0;
                  const waitMs = Math.max((resetTime * 1000) - Date.now(), 60000);
                  core.warning(`Rate limited. Waiting ${waitMs}ms...`);
                  await new Promise(resolve => setTimeout(resolve, waitMs));
                  return postChunkedComment(body, delayMs);
                }
                throw error;
              }
            }

            // Create BA analysis (chunked per operational guidelines)
            if (label === 'business-analyst') {
              core.info('Triggering autonomous BA with chunked analysis...');

              const baIntro = "## ü§ñ Autonomous BA Analysis - Overview\n\n" +
                `**Triggered by**: \`business-analyst\` label on Epic #${epicNumber}\n` +
                `**Epic**: ${epicTitle}\n` +
                `**Charter**: [BA Enhanced Capabilities v2.0](https://github.com/${context.repo.owner}/` +
                `${context.repo.repo}/blob/main/main/Foundation/business_analyst_enhanced_capabilities.md) (791 lines)\n\n` +
                "@github-copilot I am the **Business Analyst Agent (BA-PLT-001)** operating autonomously.\n\n" +
                "### Epic Content\n```\n" +
                `${epicBody.length > 2000 ? epicBody.substring(0, 2000) + '...[truncated]' : epicBody}\n` +
                "```\n\n" +
                "### Required Documents\n" +
                `- [BA Enhanced Capabilities v2.0](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/main/Foundation/business_analyst_enhanced_capabilities.md)\n` +
                `- [BRAND_STRATEGY.md](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/docs/BRAND_STRATEGY.md) (Design system: neon-cyan, Space Grotesk)\n\n` +
                "### Task Overview\n" +
                "I will post user stories as **SEPARATE COMMENTS** (one per story) to avoid GitHub API limits. " +
                "Each story will follow this format with full acceptance criteria, RICE scoring, wireframes, and test collaboration.\n\n" +
                "---\n\n" +
                "**Next**: I will post User Story #1";

              // Post intro
              await postChunkedComment(baIntro);

              // Request stories (BA will post each as separate comment)
              const baStoriesRequest = "## ü§ñ BA Request: Create User Stories\n\n" +
                `@github-copilot Please create **5-10 user stories** for Epic #${epicNumber}.\n\n` +
                "**CRITICAL**: Post **ONE STORY PER COMMENT** to avoid character limits. Use this exact format for EACH story:\n\n" +
                "```markdown\n" +
                "## User Story #[N]: [Title]\n\n" +
                "**As a** [user type]\n" +
                "**I want** [feature]\n" +
                "**So that** [benefit]\n\n" +
                "**Acceptance Criteria**:\n" +
                "- [ ] Specific measurable criterion 1\n" +
                "- [ ] Specific measurable criterion 2\n" +
                "- [ ] Edge case handling\n" +
                "- [ ] Performance requirement (e.g., <200ms latency)\n\n" +
                "**Priority**: [Must Have | Should Have | Could Have]\n" +
                "**RICE Score**: [Reach √ó Impact √ó Confidence / Effort] = [number]\n" +
                "  - Reach: [X] users/month\n" +
                "  - Impact: [score 0-3]\n" +
                "  - Confidence: [%]\n" +
                "  - Effort: [person-weeks]\n\n" +
                "**Effort**: [S/M/L/XL]\n\n" +
                "**UX/UI Design**:\n" +
                "- Wireframe: [Excalidraw ASCII art or link]\n" +
                "- Design System: Uses `--neon-cyan` accent (#00f2fe), `Space Grotesk` headings\n" +
                "- Responsive: Mobile-first, breakpoints at 768px/1024px\n" +
                "- Dark Theme: Default (#0a0a0a background)\n\n" +
                "**Test Collaboration**:\n" +
                "- Testable? Yes/No\n" +
                "- Edge Cases: [list specific scenarios]\n" +
                "- Performance Target: [P95 < Xms]\n" +
                "```\n\n" +
                "**After all stories**, post a final comment with:\n" +
                "- **Prioritization Matrix** (MoSCoW + RICE ranking)\n" +
                "- **Requirements Traceability Matrix** template\n\n" +
                "Begin posting Story #1 now.";

              await postChunkedComment(baStoriesRequest);

              core.info(`‚úÖ Autonomous BA triggered (chunked mode) for Epic #${epicNumber}`);
            }

            // Create SA analysis (chunked: 5 sections per operational guidelines)
            if (label === 'systems-architect') {
              core.info('Triggering autonomous SA with chunked analysis...');

              const saSection1 = "## ü§ñ Autonomous SA Analysis - Part 1/5: Overview\n\n" +
                `**Triggered by**: \`systems-architect\` label on Epic #${epicNumber}\n` +
                `**Epic**: ${epicTitle}\n` +
                `**Charter**: [SA Enhanced Capabilities v2.0](https://github.com/${context.repo.owner}/` +
                `${context.repo.repo}/blob/main/main/Foundation/systems_architect_enhanced_capabilities.md) (784 lines)\n\n` +
                "@github-copilot I am the **Systems Architect Agent (ARCH-PLT-001)** operating autonomously.\n\n" +
                "### Epic Content\n```\n" +
                `${epicBody.length > 2000 ? epicBody.substring(0, 2000) + '...[truncated]' : epicBody}\n` +
                "```\n\n" +
                "### Required Documents\n" +
                `- [SA Enhanced Capabilities v2.0](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/main/Foundation/systems_architect_enhanced_capabilities.md)\n` +
                "- WAOOAW Stack: Python/FastAPI, PostgreSQL, Redis, Docker, Kubernetes\n\n" +
                "### Analysis Plan (5 Parts)\n" +
                "1. **STRIDE Threat Model** (this section)\n" +
                "2. Performance Architecture\n" +
                "3. Technical Debt Analysis\n" +
                "4. Alternatives Evaluation\n" +
                "5. Architecture Decision Record (ADR)\n\n" +
                "---\n\n" +
                "**Next**: Part 2/5 (STRIDE Threat Model)";

              const saSection2 = "## ü§ñ Autonomous SA Analysis - Part 2/5: STRIDE Threat Model\n\n" +
                `@github-copilot Please perform **STRIDE threat modeling** for Epic #${epicNumber}:\n\n` +
                "### Required Analysis\n\n" +
                "**Identify 10+ Threats**:\n" +
                "- **Spoofing**: Identity verification gaps\n" +
                "- **Tampering**: Data integrity risks\n" +
                "- **Repudiation**: Audit trail gaps\n" +
                "- **Information Disclosure**: Data exposure risks\n" +
                "- **Denial of Service**: Availability risks\n" +
                "- **Elevation of Privilege**: Authorization bypasses\n\n" +
                "**For each threat**:\n" +
                "- Description: Specific attack scenario\n" +
                "- Severity: Critical/High/Medium/Low\n" +
                "- Control Type: Preventive / Detective / Corrective\n" +
                "- Mitigation: Specific implementation (not generic \"use HTTPS\")\n" +
                "- Validation: How to verify mitigation\n\n" +
                "**Attack Surface Calculation**:\n" +
                "- Entry points: [count]\n" +
                "- Risk score: [Œ£(severity √ó likelihood)]\n\n" +
                "**Compliance Check**:\n" +
                "- GDPR: [if PII involved]\n" +
                "- PCI DSS: [if payments]\n" +
                "- WAOOAW deny-by-default: [Yes/No]\n\n" +
                "---\n\n" +
                "**Next**: Part 3/5 (Performance Architecture)";

              const saSection3 = "## ü§ñ Autonomous SA Analysis - Part 3/5: Performance Architecture\n\n" +
                `@github-copilot Please design **performance architecture** for Epic #${epicNumber}:\n\n` +
                "### Performance Requirements (Quantify)\n" +
                "- **Latency Target**: P95 < [X]ms, P99 < [Y]ms\n" +
                "- **Throughput Target**: [N] requests/sec\n" +
                "- **Concurrent Users**: [M] simultaneous users\n" +
                "- **Data Volume**: [Z] records, [W] GB\n\n" +
                "### Multi-Level Caching Strategy\n" +
                "- **Browser**: Cache-Control headers, Service Worker\n" +
                "- **CDN**: CloudFlare/CloudFront for static assets\n" +
                "- **Redis**: Session data, API responses (TTL: [X]s)\n" +
                "- **PostgreSQL**: Query results, materialized views\n\n" +
                "### Database Optimization\n" +
                "- **Indexes**: Composite indexes for [query patterns]\n" +
                "- **Connection Pooling**: [min-max] connections\n" +
                "- **Query Patterns**: N+1 prevention, eager loading\n" +
                "- **Partitioning**: [if > 1M records]\n\n" +
                "### Async I/O Patterns\n" +
                "- **Background Jobs**: Celery for [long-running tasks]\n" +
                "- **Event Queue**: Redis Pub/Sub for [real-time updates]\n" +
                "- **Rate Limiting**: [N] requests/minute per user\n\n" +
                "---\n\n" +
                "**Next**: Part 4/5 (Technical Debt Analysis)";

              const saSection4 = "## ü§ñ Autonomous SA Analysis - Part 4/5: Technical Debt Analysis\n\n" +
                `@github-copilot Please analyze **technical debt** for Epic #${epicNumber}:\n\n` +
                "### Codebase Review\n" +
                "- Search existing codebase for similar features\n" +
                "- Identify reusable components/patterns\n" +
                "- Check for code smells (complexity, duplication)\n\n" +
                "### Debt Calculation\n" +
                "**Formula**: (Impact √ó 10) + (Urgency √ó 5) - (Effort √ó 2)\n\n" +
                "For each debt item:\n" +
                "- **Description**: Specific code smell or issue\n" +
                "- **Impact**: 1-10 (business/technical effect)\n" +
                "- **Urgency**: 1-10 (how soon must fix)\n" +
                "- **Effort**: 1-10 (person-days to fix)\n" +
                "- **Score**: [calculated]\n\n" +
                "### Refactoring Plan\n" +
                "If total debt score > 50:\n" +
                "- Plan refactoring sprint BEFORE new features\n" +
                "- Prioritize high-impact, low-effort fixes\n" +
                "- Set technical health budget (20% capacity)\n\n" +
                "---\n\n" +
                "**Next**: Part 5/5 (Alternatives + ADR)";

              const saSection5 = "## ü§ñ Autonomous SA Analysis - Part 5/5: Alternatives + ADR\n\n" +
                `@github-copilot Please create **ADR with 3+ alternatives** for Epic #${epicNumber}:\n\n` +
                "### Alternatives Evaluation\n\n" +
                "**Option 1**: [Approach name]\n" +
                "- **Description**: [implementation details]\n" +
                "- **Pros**: [specific benefits]\n" +
                "- **Cons**: [specific trade-offs]\n" +
                "- **Cost**: [dev time + infra cost]\n" +
                "- **Risk**: [technical/business risks]\n\n" +
                "**Option 2**: [Approach name]\n" +
                "- [Same structure]\n\n" +
                "**Option 3**: [Approach name]\n" +
                "- [Same structure]\n\n" +
                "**Decision Matrix**:\n" +
                "| Criteria (Weight) | Option 1 | Option 2 | Option 3 |\n" +
                "|-------------------|----------|----------|----------|\n" +
                "| Performance (30%) | [score]  | [score]  | [score]  |\n" +
                "| Maintainability (25%) | [score] | [score] | [score] |\n" +
                "| Cost (20%) | [score] | [score] | [score] |\n" +
                "| Time-to-Market (15%) | [score] | [score] | [score] |\n" +
                "| Scalability (10%) | [score] | [score] | [score] |\n" +
                "| **Total** | **[X]** | **[Y]** | **[Z]** |\n\n" +
                "### Architecture Decision Record\n\n" +
                "```markdown\n" +
                "# ADR-[N]: [Title]\n\n" +
                "**Status**: Proposed\n" +
                `**Date**: ${new Date().toISOString().split('T')[0]}\n` +
                `**Epic**: #${epicNumber}\n\n` +
                "## Context\n" +
                "[Problem statement, constraints, requirements]\n\n" +
                "## Decision Drivers\n" +
                "- [Driver 1]\n" +
                "- [Driver 2]\n\n" +
                "## Considered Options\n" +
                "1. Option 1 (see evaluation above)\n" +
                "2. Option 2\n" +
                "3. Option 3\n\n" +
                "## Decision\n" +
                "Selected **Option [N]** because [specific rationale with data]\n\n" +
                "## Consequences\n" +
                "- **Positive**: [benefits]\n" +
                "- **Negative**: [trade-offs accepted]\n" +
                "- **Risks**: [mitigation plans]\n" +
                "```\n\n" +
                "---\n\n" +
                "**SA Agent**: Analysis complete. All 5 sections posted.";

              // Post all 5 SA sections with rate limit protection
              await postChunkedComment(saSection1);
              await postChunkedComment(saSection2);
              await postChunkedComment(saSection3);
              await postChunkedComment(saSection4);
              await postChunkedComment(saSection5);

              core.info(`‚úÖ Autonomous SA triggered (5 chunked sections) for Epic #${epicNumber}`);
            }

  autonomous-escalation-handler:
    name: Autonomous Escalation Handler
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.action == 'created' &&
      contains(github.event.comment.body, '[ESCALATION]')
    permissions:
      issues: write
      contents: read
    steps:
      - name: Validate and Route Escalation
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment;
            const issue = context.payload.issue;
            const commentBody = comment.body || '';

            core.info('Escalation detected. Validating format...');

            // Validation: Check for 3 probable solutions (MANDATORY per guidelines)
            const solutionCount = (commentBody.match(/##\s*Probable Solution [123]/gi) || []).length;

            if (solutionCount < 3) {
              core.warning(`Escalation validation FAILED: Only ${solutionCount}/3 solutions provided`);

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ùå **Escalation Rejected - Invalid Format**\n\n` +
                      `**Validation Failed**: ${solutionCount}/3 probable solutions provided (required: 3).\n\n` +
                      `Per [Operational Guidelines](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/main/Foundation/AUTONOMOUS_AGENT_OPERATIONAL_GUIDELINES.md), ` +
                      `all escalations MUST include:\n` +
                      `1. Problem statement\n` +
                      `2. **3 probable solutions** (with pros/cons/effort/risk)\n` +
                      `3. Recommendation\n` +
                      `4. Cost impact\n\n` +
                      `Please reformat escalation with all 3 solutions and resubmit.`
              });

              return;
            }

            core.info(`‚úÖ Format validation passed: ${solutionCount}/3 solutions`);

            // Track escalation attempts (check comment history)
            const issueComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });

            const escalationComments = issueComments.data.filter(c =>
              c.body.includes('[ESCALATION]')
            );

            const attemptNumber = escalationComments.length;

            core.info(`Escalation attempt: ${attemptNumber}/3`);

            // Auto-escalate to Governor after 3 attempts (RULE #2)
            if (attemptNumber >= 3) {
              core.warning('3 escalation attempts reached. Auto-escalating to Governor (FINAL).');

              // Compile full escalation history
              const historyText = escalationComments.map((c, idx) =>
                `### Attempt ${idx + 1}\n` +
                `**Date**: ${c.created_at}\n` +
                `**Author**: @${c.user.login}\n\n` +
                `${c.body}\n\n---\n`
              ).join('\n');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üö® **Auto-Escalation to Governor (FINAL DECISION)**\n\n` +
                      `**Reason**: 3 escalation attempts reached (RULE #2 per ` +
                      `[Operational Guidelines](https://github.com/${context.repo.owner}/${context.repo.repo}/` +
                      `blob/main/main/Foundation/AUTONOMOUS_AGENT_OPERATIONAL_GUIDELINES.md))\n\n` +
                      `**Issue**: #${issue.number} - ${issue.title}\n\n` +
                      `**Escalation History**:\n${historyText}\n\n` +
                      `---\n\n` +
                      `@${context.repo.owner} **Governor Decision Required**:\n\n` +
                      `This escalation has cycled 3 times without resolution. Per RULE #3, your decision is **FINAL** (no further escalation loop).\n\n` +
                      `Please review all 3 attempts above and provide binding decision using this format:\n\n` +
                      `\`\`\`\n` +
                      `## Governor Final Decision\n\n` +
                      `**Decision**: [Selected option from history]\n` +
                      `**Rationale**: [Why this decision]\n` +
                      `**Binding Directive**: [Implementation instructions]\n` +
                      `**Precedent Seed**: PREC-GOV-[ID] [for future reference]\n` +
                      `\`\`\`\n\n` +
                      `**SLA**: 24 hours`
              });

              // Add label for Governor attention
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['governor-final-decision', 'escalation-3-attempts']
              });

              return;
            }

            // Route escalation to target agent (extract from comment)
            const targetMatch = commentBody.match(/\*\*Escalation To\*\*:\s*([^\n]+)/i);
            let targetLabel = 'governor'; // default

            if (targetMatch) {
              const target = targetMatch[1].toLowerCase();
              if (target.includes('systems architect')) targetLabel = 'systems-architect';
              else if (target.includes('business analyst')) targetLabel = 'business-analyst';
              else if (target.includes('vision guardian')) targetLabel = 'vision-guardian';
              else if (target.includes('coding')) targetLabel = 'coding-agent';
              else if (target.includes('testing')) targetLabel = 'testing-agent';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `‚úÖ **Escalation Validated and Routed**\n\n` +
                    `**Attempt**: ${attemptNumber}/3\n` +
                    `**Target**: ${targetLabel}\n` +
                    `**Format**: ‚úÖ 3 probable solutions included\n` +
                    `**SLA**: 4 hours (agents), 24 hours (Governor)\n\n` +
                    `Next escalation (if needed) will be attempt ${attemptNumber + 1}/3.` +
                    (attemptNumber === 2 ? `\n\n‚ö†Ô∏è **Warning**: This is the 2nd attempt. One more escalation will trigger auto-escalation to Governor for FINAL decision.` : '')
            });

            // Add label for target agent
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: [targetLabel, `escalation-attempt-${attemptNumber}`]
            });

            core.info(`Escalation routed to ${targetLabel}`);

  trigger-coding-agent:
    name: Trigger Coding Agent
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'closed' &&
      contains(github.event.issue.labels.*.name, 'user-story')
    steps:
      - name: Check if last user story for epic
        id: check-last-story
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);

            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }

            const epicNumber = epicMatch[1] || epicMatch[2];
            core.setOutput('epic_number', epicNumber);

            const allIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              labels: 'user-story'
            });

            const epicStories = allIssues.filter(i => {
              const body = i.body || '';
              return (body.includes('Epic #' + epicNumber) || body.includes('#' + epicNumber)) &&
                     i.labels.some(l => l.name === 'user-story');
            });

            const openStories = epicStories.filter(i => i.state === 'open');

            core.info('Epic #' + epicNumber + ' - Open stories: ' + openStories.length);
            core.setOutput('is_last_story', openStories.length === 0 ? 'true' : 'false');

            const branches = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const epicBranch = branches.data.find(b => b.name.startsWith('epic-' + epicNumber));
            if (epicBranch) {
              core.setOutput('epic_branch', epicBranch.name);
            }

      - name: Invoke Coding Agent
        if: steps.check-last-story.outputs.is_last_story == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const epicNumber = '${{ steps.check-last-story.outputs.epic_number }}';
            const epicBranch = '${{ steps.check-last-story.outputs.epic_branch }}';

            if (!epicBranch) {
              core.warning('Epic branch not found for epic #' + epicNumber);
              return;
            }

            const agentTask = `
            @github-copilot I am the Coding Agent (DEV-CODE-001) for Epic #${epicNumber}.

            **Charter**: /main/Foundation/coding_agent_charter.md
            **Epic Branch**: ${epicBranch}

            All user stories are closed. Please implement application code following my charter:

            1. Read all user-story-*.md from /docs/epics/${epicNumber}/user-stories/
            2. Review architecture analysis from /docs/epics/${epicNumber}/architecture/
            3. Implement using 7-phase incremental commit strategy
            4. Run SAST self-review (bandit, pylint, mypy, eslint)
            5. Write unit tests with 85%+ coverage
            6. Auto-generate Alembic migrations if models changed
            7. Commit incrementally with descriptive messages

            If you encounter major gaps, escalate with 3 probable solutions format.

            Begin implementation now.
            `;

            const epicIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'epic'
            });

            const epicIssue = epicIssues.data.find(i => i.number == epicNumber);

            if (epicIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: agentTask
              });

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                labels: ['coding-agent']
              });
            }

  trigger-deployment-agent:
    name: Trigger Deployment Agent
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'closed' &&
      contains(github.event.issue.labels.*.name, 'testing-complete')
    steps:
      - name: Extract epic number
        id: extract-epic
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);

            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }

            const epicNumber = epicMatch[1] || epicMatch[2];
            core.setOutput('epic_number', epicNumber);

            const branches = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const epicBranch = branches.data.find(b => b.name.startsWith('epic-' + epicNumber));
            if (epicBranch) {
              core.setOutput('epic_branch', epicBranch.name);
            }

      - name: Invoke Deployment Agent
        if: steps.extract-epic.outputs.epic_number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const epicNumber = '${{ steps.extract-epic.outputs.epic_number }}';
            const epicBranch = '${{ steps.extract-epic.outputs.epic_branch }}';

            if (!epicBranch) {
              core.warning('Epic branch not found for epic #' + epicNumber);
              return;
            }

            const agentTask = `
            @github-copilot I am the Deployment Agent (IA-CICD-001) for Epic #${epicNumber}.

            **Charter**: /infrastructure/CI_Pipeline/Waooaw Cloud Deployment Agent.md (Enhanced v2.0)
            **Epic Branch**: ${epicBranch}

            Testing is complete. Please generate infrastructure code following my enhanced capabilities:

            1. Read deployment requirements from /docs/epics/${epicNumber}/deployment-plan.md
            2. Review architecture analysis from /docs/epics/${epicNumber}/architecture/
            3. Generate using 5-phase incremental commit strategy:
               - Commit 1: Terraform modules
               - Commit 2: GCP resource stacks
               - Commit 3: Kubernetes manifests
               - Commit 4: Docker configurations
               - Commit 5: GitHub Actions workflows
            4. Run self-review (terraform validate, tflint, kubectl dry-run)
            5. Test locally using platform toolset
            6. Update UNIFIED_ARCHITECTURE.md before final commit

            If you encounter major gaps, escalate with 3 probable solutions format.

            Begin infrastructure code generation now.
            `;

            const epicIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'epic'
            });

            const epicIssue = epicIssues.data.find(i => i.number == epicNumber);

            if (epicIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: agentTask
              });

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                labels: ['deployment-agent']
              });
            }
