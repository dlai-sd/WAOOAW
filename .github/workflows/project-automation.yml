name: GitHub Project Automation

on:
  issues:
    types: [opened, labeled, closed, reopened]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, closed, reopened]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  auto-triage:
    name: Auto-Triage Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    steps:
      - name: Add to project board
        if: vars.PROJECT_URL != ''
        uses: actions/add-to-project@v0.5.0
        with:
          project-url: ${{ vars.PROJECT_URL }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set agent owner based on labels
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);

            // Auto-assign based on label
            let assignee = null;
            if (labels.includes('epic')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['vision-guardian-agent']
              });
              core.info('Epic issue - assigned to Vision Guardian Agent');

              // Create Vision Guardian Review Issue with Agent Task
              const epicTitle = issue.title;
              const epicNumber = issue.number;
              const epicBody = issue.body || '';

              const reviewBody = '## Vision Guardian Agent Task\n\n' +
                '**Epic**: #' + epicNumber + ' - ' + epicTitle + '\n\n' +
                '---\n\n' +
                '## Agent Instructions\n\n' +
                '@github-copilot You are the **Vision Guardian Agent** (GOV-002). ' +
                'Analyze this epic and provide comprehensive constitutional review.\n\n' +
                '### Your Task:\n\n' +
                '1. Read Epic #' + epicNumber + '\n' +
                '2. Analyze against /main/Foundation.md, /docs/BRAND_STRATEGY.md\n' +
                '3. Identify gaps (business, technical, vision, risk)\n' +
                '4. Propose world-class solutions\n' +
                '5. Calculate alignment score (0-100)\n' +
                '6. Assign risk level (1-4)\n' +
                '7. Post comprehensive review\n\n' +
                '### Required Analysis:\n\n' +
                '- Constitutional alignment check\n' +
                '- Gap analysis with specific solutions\n' +
                '- Risk assessment\n' +
                '- Recommendation: Approve/Revise/Reject\n\n' +
                '---\n\n' +
                '## Epic Details\n\n' +
                epicBody + '\n\n' +
                '---\n\n' +
                '**Status**: Waiting for Vision Guardian analysis\n\n' +
                '**Instructions**: Vision Guardian will post review below. ' +
                'Governor reviews and comments decision.\n\n' +
                '**Related Epic**: #' + epicNumber;

              const review = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '[VG REVIEW] Epic #' + epicNumber + ': ' + epicTitle,
                body: reviewBody,
                labels: ['vision-guardian-agent', 'vision-guardian-review', '#github-pull-request_copilot-coding-agent']
              });

              core.info(`Created Vision Guardian review issue #${review.data.number}`);

              // Comment on epic with link to review
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: `üõ°Ô∏è **Vision Guardian Review Created**: #${review.data.number}\n\nPlease complete the constitutional review before proceeding with implementation.`
              });

            } else if (labels.includes('story')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['business-analyst-agent']
              });
              core.info('Story issue - assigned to Business Analyst Agent');
            } else if (labels.includes('task')) {
              const taskType = issue.body.match(/Task Type.*?\n.*?- \[(.*?)\]/s);
              if (taskType && taskType[1].includes('Infrastructure')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['deployment-agent']
                });
              } else if (taskType && taskType[1].includes('Testing')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['testing-agent']
                });
              } else {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['systems-architect-agent']
                });
              }
              core.info('Task issue - assigned based on task type');
            } else if (labels.includes('bug')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['testing-agent']
              });
              core.info('Bug issue - assigned to Testing Agent for triage');
            }

  move-to-in-progress:
    name: Move to In Progress
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'in-progress'
    steps:
      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: 'üöÄ **Status Update**: Issue moved to **In Progress**\n\nAgent working on implementation...'
            });

  move-to-review:
    name: Move to Review
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'in-review'
    steps:
      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: 'üëÄ **Status Update**: Issue moved to **Review**\n\nAwaiting validation and approval...'
            });

  move-to-done:
    name: Move to Done
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'closed'
    steps:
      - name: Add completion comment
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['done']
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: '‚úÖ **Status Update**: Issue moved to **Done**\n\nWork completed and closed.'
            });

  link-pr-to-issue:
    name: Link PR to Issue
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    steps:
      - name: Auto-link PR to issue
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';

            // Extract issue numbers from PR body (Closes #123, Fixes #456)
            const issuePattern = /(Closes|Fixes|Resolves)\s+#(\d+)/gi;
            const matches = [...prBody.matchAll(issuePattern)];

            if (matches.length > 0) {
              for (const match of matches) {
                const issueNumber = match[2];
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  body: `üîó **PR Linked**: #${pr.number} - ${pr.title}\n\nImplementation in progress...`
                });

                // Add in-review label to issue
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  labels: ['in-review']
                });
              }
            }

  auto-close-issue-on-pr-merge:
    name: Auto-Close Issue on PR Merge
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    steps:
      - name: Close linked issues
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';

            // Extract issue numbers from PR body
            const issuePattern = /(Closes|Fixes|Resolves)\s+#(\d+)/gi;
            const matches = [...prBody.matchAll(issuePattern)];

            if (matches.length > 0) {
              for (const match of matches) {
                const issueNumber = match[2];

                // Close the issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  state: 'closed'
                });

                // Add completion comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  body: `‚úÖ **Closed via PR**: #${pr.number}\n\n**Merged by**: @${pr.merged_by.login}\n**Deployed**: Changes will be deployed in next release.`
                });
              }
            }

  autonomous-vg-analysis:
    name: Autonomous VG Analysis
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'opened' &&
      contains(github.event.issue.labels.*.name, 'vision-guardian-review')
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger Copilot Coding Agent for VG Analysis
        uses: actions/github-script@v7
        with:
          script: |
            const reviewIssue = context.payload.issue;
            const issueBody = reviewIssue.body || '';
            const epicMatch = issueBody.match(/\*\*Epic\*\*:\s+#(\d+)/);
            
            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }
            
            const epicNumber = epicMatch[1];
            
            // Get epic details
            const epic = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(epicNumber)
            });
            
            const epicTitle = epic.data.title;
            const epicBody = epic.data.body || '';
            
            // Post autonomous agent trigger comment
            const agentPrompt = `## ü§ñ Autonomous Vision Guardian Analysis
            
            **Triggered by**: Issue creation with label \`vision-guardian-review\`
            **Epic**: #${epicNumber} - ${epicTitle}
            **Charter**: /main/Foundation/vision_guardian_agent_charter.md
            
            ---
            
            @github-copilot I am the **Vision Guardian Agent (GOV-002)** operating autonomously.
            
            ### My Task (Automatic Constitutional Review):
            
            **1. Read Foundation Documents**
            - /main/Foundation.md (L0 Constitution - 824 lines)
            - /docs/BRAND_STRATEGY.md (Brand DNA)
            - /main/Foundation/vision_guardian_agent_charter.md (My charter v2.0)
            
            **2. Analyze Epic #${epicNumber}**
            \`\`\`
            ${epicBody}
            \`\`\`
            
            **3. Perform Constitutional Review**
            - ‚úÖ Business Impact Analysis: Revenue impact, market position, customer acquisition, retention, time to market
            - ‚úÖ Constitutional Alignment Check: "Agents Earn Your Business" philosophy, deny-by-default security, approval primitives, precedent seed discipline, marketplace DNA
            - ‚úÖ Gap Analysis: Business value gaps, technical gaps, vision gaps, risk gaps, scope gaps
            - ‚úÖ Precedent Search: Query /main/Foundation/precedents/*.md for similar decisions
            - ‚úÖ Risk Quantification: Financial risk, customer impact, security risk, compliance risk, reputation risk, recovery cost
            - ‚úÖ World-Class Solutions: Specific recommendations with rationale, implementation approach, priority (P0/P1/P2)
            
            **4. Calculate Scores**
            - Alignment Score (0-100): L0 Constitution (40 pts) + L1 Canonical Model (20 pts) + L2 Operations (20 pts) + L3 Learning (10 pts) + Brand DNA (10 pts)
            - Risk Level (1-4): Auto-block | Escalate | Approve with conditions | Fast-track
            
            **5. Provide Recommendation**
            Format:
            \`\`\`
            ## Vision Guardian Constitutional Review
            
            **Epic**: #${epicNumber} - ${epicTitle}
            **Alignment Score**: [X/100]
            **Risk Level**: [1-4] - [Description]
            
            ### Business Impact Analysis
            - Revenue Impact: ‚Çπ[amount]/month
            - Market Position: [analysis]
            - Customer Acquisition: [expected conversion rate]
            - Retention Impact: [churn rate effect]
            - Time to Market: [competitive advantage]
            - Strategic Value: [long-term positioning]
            
            ### Constitutional Alignment
            - L0 Constitution: [Pass/Fail] - [specific findings]
            - Brand DNA: [Pass/Fail] - ["Agents Earn Your Business" preserved?]
            - Security Posture: [Pass/Fail] - [deny-by-default maintained?]
            - Marketplace DNA: [Pass/Fail] - [try-before-hire philosophy?]
            
            ### Gap Analysis
            
            #### Business Value Gaps [P0/P1/P2]
            - [Gap description]
            - **Recommendation**: [Specific solution]
            - **Rationale**: [Why this matters]
            - **Implementation**: [How to fix]
            
            #### Technical Gaps [P0/P1/P2]
            - [Gap description with solutions]
            
            #### Vision Gaps [P0/P1/P2]
            - [Gap description with solutions]
            
            #### Risk Gaps [P0/P1/P2]
            - [Gap description with solutions]
            
            ### Precedent Analysis
            - Applicable Precedents: PREC-VG-[IDs]
            - Pattern Applied: [description]
            - Conflicts: [any conflicts with past decisions]
            
            ### Risk Quantification
            - Financial Risk: ‚Çπ[amount] potential loss
            - Customer Impact: [X] customers affected, [Y]% churn probability
            - Security Risk: ‚Çπ[breach cost], [data exposure count]
            - Compliance Risk: ‚Çπ[regulatory fine potential]
            - Reputation Risk: [NPS drop estimate], [media mentions]
            - Recovery Cost: [time and money to rollback]
            
            ### Final Recommendation
            
            **Decision**: [APPROVE | APPROVE_WITH_CONDITIONS | REVISE | REJECT]
            
            **Justification**: [2-3 sentences]
            
            **Next Steps**:
            - [Action items for Governor/Systems Architect/BA]
            
            ---
            
            **VG Agent**: Analysis complete. Awaiting Governor decision.
            \`\`\`
            
            **IMPORTANT**: 
            - Post your complete analysis as a comment on this issue
            - Include all sections from the template above
            - Be specific with recommendations (not generic advice)
            - Quantify business impact and risks with numbers
            - Reference specific lines from Foundation.md if citing violations
            
            Begin autonomous analysis now.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: reviewIssue.number,
              body: agentPrompt
            });
            
            core.info(`Autonomous VG analysis triggered for Epic #${epicNumber}`);

  vg-approval-handler:
    name: VG Approval Handler
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.action == 'created' &&
      contains(github.event.issue.labels.*.name, 'vision-guardian-review')
    permissions:
      issues: write
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Handle Governor Decision or Auto-Approve
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const commentLower = comment.toLowerCase().trim();
            const reviewIssue = context.payload.issue;
            const issueBody = reviewIssue.body || '';
            const epicMatch = issueBody.match(/\*\*Epic\*\*:\s+#(\d+)/);
            
            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }
            
            const epicNumber = epicMatch[1];
            const epic = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(epicNumber)
            });
            
            const epicTitle = epic.data.title;
            const branchSlug = epicTitle.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').substring(0, 50);
            const branchName = 'epic-' + epicNumber + '-' + branchSlug;
            
            // Check if this is VG Agent's analysis (auto-approve logic)
            const isVGAnalysis = comment.includes('## Vision Guardian Constitutional Review') || 
                                 comment.includes('**VG Agent**:');
            
            if (isVGAnalysis) {
              // Extract alignment score
              const scoreMatch = comment.match(/\*\*Alignment Score\*\*:\s*(\d+)\/100/);
              const score = scoreMatch ? parseInt(scoreMatch[1]) : 0;
              
              // Extract recommendation
              const recommendMatch = comment.match(/\*\*Decision\*\*:\s*(APPROVE|APPROVE_WITH_CONDITIONS|REVISE|REJECT)/i);
              const recommendation = recommendMatch ? recommendMatch[1].toUpperCase() : 'REVISE';
              
              core.info(`VG Analysis detected - Score: ${score}, Recommendation: ${recommendation}`);
              
              // Auto-approve if score >= 80 AND recommendation is APPROVE or APPROVE_WITH_CONDITIONS
              if ((recommendation === 'APPROVE' || recommendation === 'APPROVE_WITH_CONDITIONS') && score >= 80) {
                core.info('Auto-approving based on VG analysis (score >= 80)');
                
                // Create epic branch
                const defaultBranch = await github.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                const mainRef = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/' + defaultBranch.data.default_branch
                });
                
                try {
                  await github.rest.git.createRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: 'refs/heads/' + branchName,
                    sha: mainRef.data.object.sha
                  });
                  core.info(`Created branch: ${branchName}`);
                } catch (error) {
                  if (error.status !== 422) throw error;
                  core.info(`Branch ${branchName} already exists`);
                }
                
                // Notify epic
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(epicNumber),
                  body: `‚úÖ **Vision Guardian Approved (Autonomous)**\n\n` +
                        `**Alignment Score**: ${score}/100\n` +
                        `**Decision**: ${recommendation}\n` +
                        `**Branch**: \`${branchName}\`\n\n` +
                        `ü§ñ **Autonomous Workflow Active**:\n` +
                        `1. ‚úÖ Vision Guardian - Constitutional review complete\n` +
                        `2. üîÑ Business Analyst - Creating user stories (next)\n` +
                        `3. ‚è≥ Systems Architect - Architecture design (parallel with BA)\n` +
                        `4. ‚è≥ Coding Agent - Implementation (after BA+SA)\n` +
                        `5. ‚è≥ Testing Agent - Validation (after Coding)\n` +
                        `6. ‚è≥ Deployment Agent - Production (after Testing)\n\n` +
                        `**Systems Architect & Business Analyst notified.**`
                });
                
                // Add labels to epic for BA and SA to pick up
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(epicNumber),
                  labels: ['vg-approved', 'business-analyst', 'systems-architect']
                });
                
                // Close VG review issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: reviewIssue.number,
                  state: 'closed',
                  state_reason: 'completed'
                });
                
                return;
              } else {
                // Requires Governor manual review
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: reviewIssue.number,
                  body: `‚ö†Ô∏è **Autonomous Approval Threshold Not Met**\n\n` +
                        `**Score**: ${score}/100 (requires >= 80)\n` +
                        `**Recommendation**: ${recommendation}\n\n` +
                        `@${context.repo.owner} **Governor manual review required.**\n\n` +
                        `Comment \`approve\` to proceed or \`reject\` to decline.`
                });
                
                return;
              }
            }
            
            // Manual Governor approval/rejection
            if (commentLower === 'approve' || commentLower.startsWith('approve')) {
              core.info('Governor manually approved epic');
              const defaultBranch = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              const mainRef = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/' + defaultBranch.data.default_branch
              });
              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'refs/heads/' + branchName,
                  sha: mainRef.data.object.sha
                });
              } catch (error) {
                if (error.status !== 422) throw error;
              }
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(epicNumber),
                body: `‚úÖ **Vision Guardian Approved (Manual Override)**\n\nBranch: \`${branchName}\`\n\nSystems Architect & Business Analyst notified.`
              });
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(epicNumber),
                labels: ['vg-approved', 'business-analyst', 'systems-architect']
              });
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: reviewIssue.number,
                state: 'closed'
              });
            } else if (commentLower === 'reject' || commentLower.startsWith('reject')) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(epicNumber),
                state: 'closed',
                state_reason: 'not_planned'
              });
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: reviewIssue.number,
                state: 'closed'
              });
            }

  auto-commit-docs:
    name: Auto-Commit Docs from Issues
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'closed' &&
      (contains(github.event.issue.labels.*.name, 'vision-guardian-review') ||
       contains(github.event.issue.labels.*.name, 'architect-analysis') ||
       contains(github.event.issue.labels.*.name, 'user-story') ||
       contains(github.event.issue.labels.*.name, 'test-plan'))
    permissions:
      contents: write
      issues: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract and commit documentation
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const issueTitle = issue.title;
            const issueNumber = issue.number;
            const labels = issue.labels.map(l => l.name);

            let epicNumber = null;
            let docPath = null;
            let docContent = '';

            if (labels.includes('vision-guardian-review')) {
              const epicMatch = issueBody.match(/\*\*Epic\*\*:\s+#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1];
              docPath = `docs/epics/${epicNumber}/vision-review.md`;
              docContent = `# Vision Guardian Review\n\n` +
                `**Epic**: #${epicNumber}\n` +
                `**Review Issue**: #${issueNumber}\n` +
                `**Date**: ${new Date().toISOString().split('T')[0]}\n\n` +
                `---\n\n${issueBody}\n`;
            } else if (labels.includes('architect-analysis')) {
              const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1] || epicMatch[2];
              const analysisType = issueTitle.toLowerCase().includes('cost') ? 'cost-analysis' :
                                   issueTitle.toLowerCase().includes('compliance') ? 'compliance-check' :
                                   issueTitle.toLowerCase().includes('simulation') ? 'simulation-results' :
                                   'gap-analysis';
              docPath = `docs/epics/${epicNumber}/architecture/${analysisType}.md`;
              docContent = `# ${issueTitle}\n\n` +
                `**Epic**: #${epicNumber}\n` +
                `**Analysis Issue**: #${issueNumber}\n\n` +
                `---\n\n${issueBody}\n`;
            } else if (labels.includes('user-story')) {
              const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1] || epicMatch[2];
              docPath = `docs/epics/${epicNumber}/user-stories/${issueNumber}-story.md`;
              docContent = `# User Story: ${issueTitle}\n\n` +
                `**Story Issue**: #${issueNumber}\n\n` +
                `---\n\n${issueBody}\n`;
            } else if (labels.includes('test-plan')) {
              const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);
              if (!epicMatch) return;
              epicNumber = epicMatch[1] || epicMatch[2];
              docPath = `docs/epics/${epicNumber}/test-plans/${issueNumber}-test-plan.md`;
              docContent = `# Test Plan: ${issueTitle}\n\n` +
                `**Test Issue**: #${issueNumber}\n\n` +
                `---\n\n${issueBody}\n`;
            }

            if (!docPath || !epicNumber) {
              core.info('No doc path determined');
              return;
            }

            const branches = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const epicBranch = branches.data.find(b => b.name.startsWith('epic-' + epicNumber));
            if (!epicBranch) {
              core.warning('Epic branch not found for epic #' + epicNumber);
              return;
            }

            core.info('Committing to branch: ' + epicBranch.name);

            const fs = require('fs');
            const path = require('path');
            const dirPath = path.dirname(docPath);

            await exec.exec('git', ['config', 'user.name', 'github-actions[bot]']);
            await exec.exec('git', ['config', 'user.email', 'github-actions[bot]@users.noreply.github.com']);
            await exec.exec('git', ['fetch', 'origin', epicBranch.name]);
            await exec.exec('git', ['checkout', epicBranch.name]);
            await exec.exec('mkdir', ['-p', dirPath]);

            fs.writeFileSync(docPath, docContent);

            await exec.exec('git', ['add', docPath]);
            await exec.exec('git', ['commit', '-m', `docs: archive issue #${issueNumber} to ${docPath}`]);
            await exec.exec('git', ['push', 'origin', epicBranch.name]);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `üìù **Documentation Archived**\n\nCommitted to: \`${docPath}\` on branch \`${epicBranch.name}\``
            });

  autonomous-ba-sa-trigger:
    name: Autonomous BA & SA Trigger
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'labeled' &&
      (github.event.label.name == 'business-analyst' || github.event.label.name == 'systems-architect')
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger Autonomous BA and SA Analysis
        uses: actions/github-script@v7
        with:
          script: |
            const epic = context.payload.issue;
            const epicNumber = epic.number;
            const epicTitle = epic.title;
            const epicBody = epic.body || '';
            const label = context.payload.label.name;
            
            // Create BA analysis issue
            if (label === 'business-analyst') {
              const baPrompt = `## ü§ñ Autonomous Business Analyst Analysis
            
            **Triggered by**: Epic #${epicNumber} labeled with \`business-analyst\`
            **Epic**: ${epicTitle}
            **Charter**: /main/Foundation/business_analyst_enhanced_capabilities.md (v2.0 - 791 lines)
            
            ---
            
            @github-copilot I am the **Business Analyst Agent (BA-PLT-001)** operating autonomously.
            
            ### My Task (Automatic Epic Breakdown):
            
            **1. Read Epic #${epicNumber}**
            \`\`\`
            ${epicBody}
            \`\`\`
            
            **2. Read Enhanced Capabilities**
            - /main/Foundation/business_analyst_enhanced_capabilities.md
            - UX/UI Design: WAOOAW design system, Excalidraw wireframes, Figma mockups
            - User Research: Interview guides, surveys, usability testing, personas
            - Story Prioritization: MoSCoW, RICE scoring, Value vs Effort matrix
            
            **3. Perform Epic Breakdown**
            
            #### A. Create User Stories (5-10 stories)
            Format each story:
            \`\`\`markdown
            ## User Story #[N]: [Title]
            
            **As a** [user type]
            **I want** [feature]
            **So that** [benefit]
            
            **Acceptance Criteria**:
            - [ ] Specific measurable criterion 1
            - [ ] Specific measurable criterion 2
            - [ ] Edge case handling
            - [ ] Performance requirement (e.g., <200ms latency)
            
            **Priority**: [Must Have | Should Have | Could Have]
            **RICE Score**: [calculation] = (Reach √ó Impact √ó Confidence) / Effort
            **Effort**: [S/M/L/XL]
            
            **UX/UI Design**:
            - Wireframe: [Excalidraw sketch or ASCII art]
            - Figma Link: [if high-fidelity needed]
            - Responsive Breakpoints: Mobile/Tablet/Desktop
            - Design System: Uses \`--neon-cyan\` accent, \`Space Grotesk\` headings
            
            **Test Collaboration**:
            - Testable? [Yes/No]
            - Edge Cases: [list]
            - Performance Target: [e.g., P95 < 200ms]
            \`\`\`
            
            #### B. Prioritize Stories
            - Apply MoSCoW classification (Must/Should/Could/Won't Have)
            - Calculate RICE scores for each story
            - Create Value vs Effort matrix (Quick Wins / Major Projects / Fill-ins / Time Sinks)
            
            #### C. Create UX/UI Wireframes
            - For each user-facing story, create Excalidraw wireframe
            - Note design system usage (colors, fonts, components)
            - Specify responsive behavior
            
            #### D. Initialize Requirements Traceability
            Create traceability matrix:
            \`\`\`markdown
            | Epic | Requirement ID | User Story | Implementation | Test ID |
            |------|----------------|------------|----------------|---------|
            | #${epicNumber} | REQ-${epicNumber}.1 | [Story title] | [PR link when coded] | [Test ID when tested] |
            \`\`\`
            
            **4. Post Analysis**
            - Comment full breakdown on Epic #${epicNumber}
            - Include all user stories with RICE scores
            - Include prioritization matrix
            - Include wireframes (ASCII or links)
            - Include traceability matrix
            
            **IMPORTANT**:
            - Create 5-10 user stories (not just 1-2)
            - Each story must have specific acceptance criteria
            - Include UX/UI designs (wireframes or Figma links)
            - Calculate RICE scores for prioritization
            - Make stories testable (collaborate with Testing Agent mindset)
            
            Begin autonomous BA analysis now.`;
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: baPrompt
              });
              
              core.info(`Autonomous BA triggered for Epic #${epicNumber}`);
            }
            
            // Create SA analysis issue (parallel with BA)
            if (label === 'systems-architect') {
              const saPrompt = `## ü§ñ Autonomous Systems Architect Analysis
            
            **Triggered by**: Epic #${epicNumber} labeled with \`systems-architect\`
            **Epic**: ${epicTitle}
            **Charter**: /main/Foundation/systems_architect_enhanced_capabilities.md (v2.0 - 784 lines)
            
            ---
            
            @github-copilot I am the **Systems Architect Agent (ARCH-PLT-001)** operating autonomously.
            
            ### My Task (Automatic Architecture Design):
            
            **1. Read Epic #${epicNumber}**
            \`\`\`
            ${epicBody}
            \`\`\`
            
            **2. Read Enhanced Capabilities**
            - /main/Foundation/systems_architect_enhanced_capabilities.md
            - Security Architecture Review: STRIDE threat modeling
            - Technical Debt Analysis: Code smell detection, debt register
            - Performance Architecture: Caching strategy, database optimization
            - Alternatives Evaluation: Decision framework with 3+ options
            - Architecture Decision Records: Living ADRs
            
            **3. Perform Architecture Analysis**
            
            #### A. Security Architecture Review (STRIDE)
            - Identify threats: Spoofing, Tampering, Repudiation, Information Disclosure, DoS, Elevation of Privilege
            - Map threats to controls (Preventive / Detective / Corrective)
            - Calculate attack surface: Entry points, risk scores
            - Validate compliance: GDPR (if PII), PCI DSS (if payments)
            
            #### B. Performance Architecture
            - Define performance requirements: Latency targets (P95 < 200ms), throughput (500 req/sec)
            - Design multi-level caching: Browser ‚Üí CDN ‚Üí Redis ‚Üí PostgreSQL
            - Database optimization: Composite indexes, query patterns, connection pooling
            - Async I/O patterns: Celery for background tasks
            
            #### C. Technical Debt Analysis
            - Review existing codebase for similar features
            - Identify code smells: Cyclomatic complexity, duplication
            - Estimate debt cost: (Impact √ó 10) + (Urgency √ó 5) - (Effort √ó 2)
            - Plan refactoring sprints if debt > threshold
            
            #### D. Alternatives Evaluation
            - Propose 3+ architecture alternatives
            - Create decision matrix with weighted criteria
            - Select recommended approach with rationale
            
            #### E. Create Architecture Decision Record (ADR)
            Format:
            \`\`\`markdown
            # ADR-[N]: [Title]
            
            **Status**: Proposed
            **Date**: ${new Date().toISOString().split('T')[0]}
            **Epic**: #${epicNumber}
            
            ## Context
            [Problem statement and constraints]
            
            ## Decision Drivers
            - [Driver 1]
            - [Driver 2]
            
            ## Considered Options
            1. **Option 1**: [description]
               - Pros: [list]
               - Cons: [list]
               - Cost: [estimate]
            
            2. **Option 2**: [description]
               - Pros/Cons/Cost
            
            3. **Option 3**: [description]
               - Pros/Cons/Cost
            
            ## Decision
            Selected **Option [N]** because [rationale]
            
            ## Consequences
            - Positive: [benefits]
            - Negative: [trade-offs]
            - Risks: [mitigation plans]
            \`\`\`
            
            **4. Post Analysis**
            - Comment full architecture design on Epic #${epicNumber}
            - Include STRIDE threat model (10 threats minimum)
            - Include performance targets and caching strategy
            - Include technical debt analysis
            - Include ADR with 3+ alternatives
            - Include database schema if applicable
            
            **IMPORTANT**:
            - Be specific with threat mitigations (not generic "use HTTPS")
            - Quantify performance targets (numbers, not "fast enough")
            - Evaluate 3+ alternatives (not just 1 obvious choice)
            - Create production-ready ADR
            
            Begin autonomous SA analysis now.`;
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: saPrompt
              });
              
              core.info(`Autonomous SA triggered for Epic #${epicNumber}`);
            }

  trigger-coding-agent:
    name: Trigger Coding Agent
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'closed' &&
      contains(github.event.issue.labels.*.name, 'user-story')
    steps:
      - name: Check if last user story for epic
        id: check-last-story
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);

            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }

            const epicNumber = epicMatch[1] || epicMatch[2];
            core.setOutput('epic_number', epicNumber);

            const allIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              labels: 'user-story'
            });

            const epicStories = allIssues.filter(i => {
              const body = i.body || '';
              return (body.includes('Epic #' + epicNumber) || body.includes('#' + epicNumber)) &&
                     i.labels.some(l => l.name === 'user-story');
            });

            const openStories = epicStories.filter(i => i.state === 'open');

            core.info('Epic #' + epicNumber + ' - Open stories: ' + openStories.length);
            core.setOutput('is_last_story', openStories.length === 0 ? 'true' : 'false');

            const branches = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const epicBranch = branches.data.find(b => b.name.startsWith('epic-' + epicNumber));
            if (epicBranch) {
              core.setOutput('epic_branch', epicBranch.name);
            }

      - name: Invoke Coding Agent
        if: steps.check-last-story.outputs.is_last_story == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const epicNumber = '${{ steps.check-last-story.outputs.epic_number }}';
            const epicBranch = '${{ steps.check-last-story.outputs.epic_branch }}';

            if (!epicBranch) {
              core.warning('Epic branch not found for epic #' + epicNumber);
              return;
            }

            const agentTask = `
            @github-copilot I am the Coding Agent (DEV-CODE-001) for Epic #${epicNumber}.

            **Charter**: /main/Foundation/coding_agent_charter.md
            **Epic Branch**: ${epicBranch}

            All user stories are closed. Please implement application code following my charter:

            1. Read all user-story-*.md from /docs/epics/${epicNumber}/user-stories/
            2. Review architecture analysis from /docs/epics/${epicNumber}/architecture/
            3. Implement using 7-phase incremental commit strategy
            4. Run SAST self-review (bandit, pylint, mypy, eslint)
            5. Write unit tests with 85%+ coverage
            6. Auto-generate Alembic migrations if models changed
            7. Commit incrementally with descriptive messages

            If you encounter major gaps, escalate with 3 probable solutions format.

            Begin implementation now.
            `;

            const epicIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'epic'
            });

            const epicIssue = epicIssues.data.find(i => i.number == epicNumber);

            if (epicIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: agentTask
              });

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                labels: ['coding-agent']
              });
            }

  trigger-deployment-agent:
    name: Trigger Deployment Agent
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'closed' &&
      contains(github.event.issue.labels.*.name, 'testing-complete')
    steps:
      - name: Extract epic number
        id: extract-epic
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const epicMatch = issueBody.match(/Epic #(\d+)|#(\d+)/);

            if (!epicMatch) {
              core.info('No epic reference found');
              return;
            }

            const epicNumber = epicMatch[1] || epicMatch[2];
            core.setOutput('epic_number', epicNumber);

            const branches = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const epicBranch = branches.data.find(b => b.name.startsWith('epic-' + epicNumber));
            if (epicBranch) {
              core.setOutput('epic_branch', epicBranch.name);
            }

      - name: Invoke Deployment Agent
        if: steps.extract-epic.outputs.epic_number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const epicNumber = '${{ steps.extract-epic.outputs.epic_number }}';
            const epicBranch = '${{ steps.extract-epic.outputs.epic_branch }}';

            if (!epicBranch) {
              core.warning('Epic branch not found for epic #' + epicNumber);
              return;
            }

            const agentTask = `
            @github-copilot I am the Deployment Agent (IA-CICD-001) for Epic #${epicNumber}.

            **Charter**: /infrastructure/CI_Pipeline/Waooaw Cloud Deployment Agent.md (Enhanced v2.0)
            **Epic Branch**: ${epicBranch}

            Testing is complete. Please generate infrastructure code following my enhanced capabilities:

            1. Read deployment requirements from /docs/epics/${epicNumber}/deployment-plan.md
            2. Review architecture analysis from /docs/epics/${epicNumber}/architecture/
            3. Generate using 5-phase incremental commit strategy:
               - Commit 1: Terraform modules
               - Commit 2: GCP resource stacks
               - Commit 3: Kubernetes manifests
               - Commit 4: Docker configurations
               - Commit 5: GitHub Actions workflows
            4. Run self-review (terraform validate, tflint, kubectl dry-run)
            5. Test locally using platform toolset
            6. Update UNIFIED_ARCHITECTURE.md before final commit

            If you encounter major gaps, escalate with 3 probable solutions format.

            Begin infrastructure code generation now.
            `;

            const epicIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'epic'
            });

            const epicIssue = epicIssues.data.find(i => i.number == epicNumber);

            if (epicIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                body: agentTask
              });

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: epicNumber,
                labels: ['deployment-agent']
              });
            }
