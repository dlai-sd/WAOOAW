name: WAOOAW Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options: [demo, uat, prod]
        default: demo
      terraform_action:
        description: "Terraform action"
        required: true
        type: choice
        options: [plan, apply]
        default: plan

permissions:
  contents: read
  id-token: write

concurrency:
  group: waooaw-deploy-${{ inputs.environment }}
  cancel-in-progress: false

env:
  GCP_PROJECT_ID: waooaw-oauth
  GCP_REGION: asia-south1
  GCP_REGISTRY: asia-south1-docker.pkg.dev/waooaw-oauth/waooaw

jobs:
  resolve:
    name: Resolve Inputs
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Compute image tag
        id: tag
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          SHA_SHORT="${GITHUB_SHA::7}"
          echo "tag=${ENV}-${SHA_SHORT}-${GITHUB_RUN_NUMBER}" >> "$GITHUB_OUTPUT"

  detect:
    name: Detect Components
    runs-on: ubuntu-latest
    outputs:
      has_cp: ${{ steps.detect.outputs.has_cp }}
      has_pp: ${{ steps.detect.outputs.has_pp }}
      has_plant: ${{ steps.detect.outputs.has_plant }}
      has_plant_gateway: ${{ steps.detect.outputs.has_plant_gateway }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect component Dockerfiles
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          has_cp=false
          has_pp=false
          has_plant=false
          has_plant_gateway=false

          if [ -f src/CP/BackEnd/Dockerfile ] && [ -f src/CP/FrontEnd/Dockerfile ]; then
            has_cp=true
          fi

          if [ -f src/PP/BackEnd/Dockerfile ] && [ -f src/PP/FrontEnd/Dockerfile ]; then
            has_pp=true
          fi

          if [ -f src/Plant/BackEnd/Dockerfile ]; then
            has_plant=true
          fi

          if [ -f src/Plant/Gateway/Dockerfile ]; then
            has_plant_gateway=true
          fi

          echo "has_cp=${has_cp}" >> "$GITHUB_OUTPUT"
          echo "has_pp=${has_pp}" >> "$GITHUB_OUTPUT"
          echo "has_plant=${has_plant}" >> "$GITHUB_OUTPUT"
          echo "has_plant_gateway=${has_plant_gateway}" >> "$GITHUB_OUTPUT"

      - name: Fail if no components detected
        if: steps.detect.outputs.has_cp != 'true' && steps.detect.outputs.has_pp != 'true' && steps.detect.outputs.has_plant != 'true'
        run: |
          echo "No deployable components detected (missing Dockerfiles)." >&2
          echo "Expected at least one of:" >&2
          echo "- src/CP/BackEnd/Dockerfile + src/CP/FrontEnd/Dockerfile" >&2
          echo "- src/PP/BackEnd/Dockerfile + src/PP/FrontEnd/Dockerfile" >&2
          echo "- src/Plant/BackEnd/Dockerfile" >&2
          exit 1

  build:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: [resolve, detect]
    environment: ${{ inputs.environment }}
    timeout-minutes: 40

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate OAuth client id configured (for CP/PP frontends)
        if: needs.detect.outputs.has_cp == 'true' || needs.detect.outputs.has_pp == 'true'
        env:
          GOOGLE_OAUTH_CLIENT_ID: ${{ vars.GOOGLE_OAUTH_CLIENT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${GOOGLE_OAUTH_CLIENT_ID}" ]; then
            echo "Missing GitHub Environment var: GOOGLE_OAUTH_CLIENT_ID"
            exit 1
          fi

      - name: Authenticate to Google Cloud
        if: vars.GCP_WORKLOAD_IDENTITY_PROVIDER != '' && vars.GCP_SERVICE_ACCOUNT_EMAIL != ''
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Authenticate to Google Cloud (JSON key fallback)
        if: ${{ !(vars.GCP_WORKLOAD_IDENTITY_PROVIDER != '' && vars.GCP_SERVICE_ACCOUNT_EMAIL != '') }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker asia-south1-docker.pkg.dev

      - name: Build & Push CP images
        if: needs.detect.outputs.has_cp == 'true'
        env:
          VITE_GOOGLE_CLIENT_ID: ${{ vars.GOOGLE_OAUTH_CLIENT_ID }}
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve.outputs.tag }}"

          docker build \
            -t "${{ env.GCP_REGISTRY }}/cp-backend:${TAG}" \
            -t "${{ env.GCP_REGISTRY }}/cp-backend:${{ inputs.environment }}-latest" \
            -f src/CP/BackEnd/Dockerfile \
            src/CP/BackEnd
          docker push "${{ env.GCP_REGISTRY }}/cp-backend:${TAG}"
          docker push "${{ env.GCP_REGISTRY }}/cp-backend:${{ inputs.environment }}-latest"

          docker build \
            -t "${{ env.GCP_REGISTRY }}/cp:${TAG}" \
            -t "${{ env.GCP_REGISTRY }}/cp:${{ inputs.environment }}-latest" \
            --build-arg VITE_GOOGLE_CLIENT_ID="${VITE_GOOGLE_CLIENT_ID}" \
            --build-arg VITE_ENVIRONMENT="${{ inputs.environment }}" \
            -f src/CP/FrontEnd/Dockerfile \
            src/CP/FrontEnd
          docker push "${{ env.GCP_REGISTRY }}/cp:${TAG}"
          docker push "${{ env.GCP_REGISTRY }}/cp:${{ inputs.environment }}-latest"

      - name: Build & Push PP images
        if: needs.detect.outputs.has_pp == 'true'
        env:
          VITE_GOOGLE_CLIENT_ID: ${{ vars.GOOGLE_OAUTH_CLIENT_ID }}
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve.outputs.tag }}"

          docker build \
            -t "${{ env.GCP_REGISTRY }}/pp-backend:${TAG}" \
            -t "${{ env.GCP_REGISTRY }}/pp-backend:${{ inputs.environment }}-latest" \
            -f src/PP/BackEnd/Dockerfile \
            src/PP/BackEnd
          docker push "${{ env.GCP_REGISTRY }}/pp-backend:${TAG}"
          docker push "${{ env.GCP_REGISTRY }}/pp-backend:${{ inputs.environment }}-latest"

          docker build \
            -t "${{ env.GCP_REGISTRY }}/pp:${TAG}" \
            -t "${{ env.GCP_REGISTRY }}/pp:${{ inputs.environment }}-latest" \
            --build-arg VITE_GOOGLE_CLIENT_ID="${VITE_GOOGLE_CLIENT_ID}" \
            --build-arg VITE_ENVIRONMENT="${{ inputs.environment }}" \
            -f src/PP/FrontEnd/Dockerfile \
            src/PP/FrontEnd
          docker push "${{ env.GCP_REGISTRY }}/pp:${TAG}"
          docker push "${{ env.GCP_REGISTRY }}/pp:${{ inputs.environment }}-latest"

      - name: Build & Push Plant Backend image
        if: needs.detect.outputs.has_plant == 'true'
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve.outputs.tag }}"
          docker build \
            -t "${{ env.GCP_REGISTRY }}/plant-backend:${TAG}" \
            -t "${{ env.GCP_REGISTRY }}/plant-backend:${{ inputs.environment }}-latest" \
            -f src/Plant/BackEnd/Dockerfile \
            src/Plant/BackEnd
          docker push "${{ env.GCP_REGISTRY }}/plant-backend:${TAG}"
          docker push "${{ env.GCP_REGISTRY }}/plant-backend:${{ inputs.environment }}-latest"

      - name: Build & Push Plant Gateway image
        if: needs.detect.outputs.has_plant_gateway == 'true'
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve.outputs.tag }}"
          docker build \
            -t "${{ env.GCP_REGISTRY }}/plant-gateway:${TAG}" \
            -t "${{ env.GCP_REGISTRY }}/plant-gateway:${{ inputs.environment }}-latest" \
            -f src/Plant/Gateway/Dockerfile \
            src/Plant/Gateway
          docker push "${{ env.GCP_REGISTRY }}/plant-gateway:${TAG}"
          docker push "${{ env.GCP_REGISTRY }}/plant-gateway:${{ inputs.environment }}-latest"

  terraform_plan:
    name: Terraform Plan (Stacks)
    runs-on: ubuntu-latest
    needs: [resolve, detect, build]
    if: inputs.terraform_action == 'plan'
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        if: vars.GCP_WORKLOAD_IDENTITY_PROVIDER != '' && vars.GCP_SERVICE_ACCOUNT_EMAIL != ''
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Authenticate to Google Cloud (JSON key fallback)
        if: ${{ !(vars.GCP_WORKLOAD_IDENTITY_PROVIDER != '' && vars.GCP_SERVICE_ACCOUNT_EMAIL != '') }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform fmt check (stacks + modules)
        run: terraform fmt -recursive -check cloud/terraform/stacks cloud/terraform/modules

      - name: Plan CP stack
        if: needs.detect.outputs.has_cp == 'true'
        working-directory: cloud/terraform/stacks/cp
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          TAG="${{ needs.resolve.outputs.tag }}"
          terraform init -backend=false -input=false
          terraform validate
          terraform init \
            -backend-config="prefix=env/${ENV}/cp" \
            -reconfigure \
            -input=false
          terraform plan \
            -lock-timeout=5m \
            -var-file="environments/${ENV}.tfvars" \
            -var="cp_frontend_image=${{ env.GCP_REGISTRY }}/cp:${TAG}" \
            -var="cp_backend_image=${{ env.GCP_REGISTRY }}/cp-backend:${TAG}"

      - name: Plan PP stack
        if: needs.detect.outputs.has_pp == 'true'
        working-directory: cloud/terraform/stacks/pp
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          TAG="${{ needs.resolve.outputs.tag }}"
          terraform init -backend=false -input=false
          terraform validate
          terraform init \
            -backend-config="prefix=env/${ENV}/pp" \
            -reconfigure \
            -input=false
          terraform plan \
            -lock-timeout=5m \
            -var-file="environments/${ENV}.tfvars" \
            -var="pp_frontend_image=${{ env.GCP_REGISTRY }}/pp:${TAG}" \
            -var="pp_backend_image=${{ env.GCP_REGISTRY }}/pp-backend:${TAG}"

      - name: Plan Plant stack
        if: needs.detect.outputs.has_plant == 'true'
        working-directory: cloud/terraform/stacks/plant
        env:
          TF_VAR_database_password: ${{ secrets.PLANT_DB_PASSWORD }}
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          TAG="${{ needs.resolve.outputs.tag }}"
          terraform init -backend=false -input=false
          terraform validate
          terraform init \
            -backend-config="prefix=env/${ENV}/plant" \
            -reconfigure \
            -input=false

          # Attempt plan with shorter timeout - if locked, check if stale
          if ! terraform plan \
            -lock-timeout=2m \
            -var-file="environments/${ENV}.tfvars" \
            -var="plant_backend_image=${{ env.GCP_REGISTRY }}/plant-backend:${TAG}" \
            -var="plant_gateway_image=${{ env.GCP_REGISTRY }}/plant-gateway:${TAG}" 2>&1 | tee plan_output.txt; then

            # Check if error is due to lock
            if grep -q "Error acquiring the state lock" plan_output.txt; then
              echo "::warning::Terraform state is locked. Checking if lock is stale..."

              # Extract lock ID and timestamp from error
              LOCK_ID=$(grep "ID:" plan_output.txt | awk '{print $2}')
              LOCK_TIME=$(grep "Created:" plan_output.txt | sed 's/.*Created: //' | awk '{print $1, $2}')

              echo "Lock ID: $LOCK_ID"
              echo "Lock created: $LOCK_TIME"

              # Calculate lock age in seconds
              LOCK_EPOCH=$(date -d "$LOCK_TIME" +%s 2>/dev/null || date -j -f "%Y-%m-%d %H:%M:%S" "$LOCK_TIME" +%s)
              NOW_EPOCH=$(date +%s)
              LOCK_AGE=$((NOW_EPOCH - LOCK_EPOCH))
              LOCK_AGE_MIN=$((LOCK_AGE / 60))

              echo "Lock age: ${LOCK_AGE_MIN} minutes"

              # Only unlock if older than 20 minutes (stale lock from cancelled/failed job)
              if [ $LOCK_AGE -gt 1200 ]; then
                echo "::warning::Lock is stale (${LOCK_AGE_MIN} min old). Auto-unlocking..."
                terraform force-unlock -force "$LOCK_ID"

                # Retry plan after unlock
                terraform plan \
                  -lock-timeout=5m \
                  -var-file="environments/${ENV}.tfvars" \
                  -var="plant_backend_image=${{ env.GCP_REGISTRY }}/plant-backend:${TAG}" \
                  -var="plant_gateway_image=${{ env.GCP_REGISTRY }}/plant-gateway:${TAG}"
              else
                echo "::error::Lock is recent (${LOCK_AGE_MIN} min old). Another job may be in progress."
                echo "::error::Wait for the other job to complete or manually investigate."
                exit 1
              fi
            else
              # Different error, fail immediately
              cat plan_output.txt
              exit 1
            fi
          fi

  terraform_apply:
    name: Terraform Apply (Stacks)
    runs-on: ubuntu-latest
    needs: [resolve, detect, build]
    if: inputs.terraform_action == 'apply'
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        if: vars.GCP_WORKLOAD_IDENTITY_PROVIDER != '' && vars.GCP_SERVICE_ACCOUNT_EMAIL != ''
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Authenticate to Google Cloud (JSON key fallback)
        if: ${{ !(vars.GCP_WORKLOAD_IDENTITY_PROVIDER != '' && vars.GCP_SERVICE_ACCOUNT_EMAIL != '') }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform fmt check (stacks + modules)
        run: terraform fmt -recursive -check cloud/terraform/stacks cloud/terraform/modules

      - name: Terraform validate (no backend)
        shell: bash
        run: |
          set -euo pipefail
          for d in cloud/terraform/stacks/cp cloud/terraform/stacks/pp cloud/terraform/stacks/plant; do
            echo "--- validate: $d"
            (cd "$d" && terraform init -backend=false -input=false >/dev/null && terraform validate)
          done

      - name: Apply CP stack
        if: needs.detect.outputs.has_cp == 'true'
        working-directory: cloud/terraform/stacks/cp
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          TAG="${{ needs.resolve.outputs.tag }}"
          terraform init \
            -backend-config="prefix=env/${ENV}/cp" \
            -reconfigure \
            -input=false
          terraform plan \
            -lock-timeout=5m \
            -var-file="environments/${ENV}.tfvars" \
            -var="cp_frontend_image=${{ env.GCP_REGISTRY }}/cp:${TAG}" \
            -var="cp_backend_image=${{ env.GCP_REGISTRY }}/cp-backend:${TAG}"
          terraform apply -auto-approve \
            -lock-timeout=5m \
            -var-file="environments/${ENV}.tfvars" \
            -var="cp_frontend_image=${{ env.GCP_REGISTRY }}/cp:${TAG}" \
            -var="cp_backend_image=${{ env.GCP_REGISTRY }}/cp-backend:${TAG}"

      - name: Apply PP stack
        if: needs.detect.outputs.has_pp == 'true'
        working-directory: cloud/terraform/stacks/pp
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          TAG="${{ needs.resolve.outputs.tag }}"
          terraform init \
            -backend-config="prefix=env/${ENV}/pp" \
            -reconfigure \
            -input=false
          terraform plan \
            -lock-timeout=5m \
            -var-file="environments/${ENV}.tfvars" \
            -var="pp_frontend_image=${{ env.GCP_REGISTRY }}/pp:${TAG}" \
            -var="pp_backend_image=${{ env.GCP_REGISTRY }}/pp-backend:${TAG}"
          terraform apply -auto-approve \
            -lock-timeout=5m \
            -var-file="environments/${ENV}.tfvars" \
            -var="pp_frontend_image=${{ env.GCP_REGISTRY }}/pp:${TAG}" \
            -var="pp_backend_image=${{ env.GCP_REGISTRY }}/pp-backend:${TAG}"

      - name: Apply Plant stack
        if: needs.detect.outputs.has_plant == 'true'
        working-directory: cloud/terraform/stacks/plant
        env:
          TF_VAR_database_password: ${{ secrets.PLANT_DB_PASSWORD }}
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          TAG="${{ needs.resolve.outputs.tag }}"
          terraform init \
            -backend-config="prefix=env/${ENV}/plant" \
            -reconfigure \
            -input=false

          # Attempt plan with shorter timeout - if locked, check if stale
          if ! terraform plan \
            -lock-timeout=2m \
            -var-file="environments/${ENV}.tfvars" \
            -var="plant_backend_image=${{ env.GCP_REGISTRY }}/plant-backend:${TAG}" 2>&1 | tee plan_output.txt; then

            # Check if error is due to lock
            if grep -q "Error acquiring the state lock" plan_output.txt; then
              echo "::warning::Terraform state is locked. Checking if lock is stale..."

              # Extract lock ID and timestamp from error
              LOCK_ID=$(grep "ID:" plan_output.txt | awk '{print $2}')
              LOCK_TIME=$(grep "Created:" plan_output.txt | sed 's/.*Created: //' | awk '{print $1, $2}')

              echo "Lock ID: $LOCK_ID"
              echo "Lock created: $LOCK_TIME"

              # Calculate lock age in seconds
              LOCK_EPOCH=$(date -d "$LOCK_TIME" +%s 2>/dev/null || date -j -f "%Y-%m-%d %H:%M:%S" "$LOCK_TIME" +%s)
              NOW_EPOCH=$(date +%s)
              LOCK_AGE=$((NOW_EPOCH - LOCK_EPOCH))
              LOCK_AGE_MIN=$((LOCK_AGE / 60))

              echo "Lock age: ${LOCK_AGE_MIN} minutes"

              # Only unlock if older than 20 minutes (stale lock from cancelled/failed job)
              if [ $LOCK_AGE -gt 1200 ]; then
                echo "::warning::Lock is stale (${LOCK_AGE_MIN} min old). Auto-unlocking..."
                terraform force-unlock -force "$LOCK_ID"

                # Retry plan after unlock
                terraform plan \
                  -lock-timeout=5m \
                  -var-file="environments/${ENV}.tfvars" \
                  -var="plant_backend_image=${{ env.GCP_REGISTRY }}/plant-backend:${TAG}"
              else
                echo "::error::Lock is recent (${LOCK_AGE_MIN} min old). Another job may be in progress."
                echo "::error::Wait for the other job to complete or manually investigate."
                exit 1
              fi
            else
              # Different error, fail immediately
              cat plan_output.txt
              exit 1
            fi
          fi

          # If plan succeeded, proceed with apply
          terraform apply -auto-approve \
            -lock-timeout=5m \
            -var-file="environments/${ENV}.tfvars" \
            -var="plant_backend_image=${{ env.GCP_REGISTRY }}/plant-backend:${TAG}" \
            -var="plant_gateway_image=${{ env.GCP_REGISTRY }}/plant-gateway:${TAG}"

      - name: Wait for services ready
        if: inputs.terraform_action == 'apply'
        run: |
          echo "Waiting 30 seconds for Cloud Run services to propagate..."
          sleep 30

      - name: Test CP health endpoint
        if: inputs.terraform_action == 'apply' && needs.detect.outputs.has_cp == 'true'
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          URL="https://cp.${ENV}.waooaw.com/health"

          echo "Testing CP health: $URL"
          for i in {1..10}; do
            echo "Attempt $i/10..."
            if curl -f -s -m 10 "$URL" | grep -q "healthy\|ok"; then
              echo "✅ CP health check passed"
              exit 0
            fi
            if [ $i -lt 10 ]; then
              echo "Retrying in 30 seconds..."
              sleep 30
            fi
          done
          echo "::error::CP health check failed after 10 attempts"
          exit 1

      - name: Test PP health endpoint
        if: inputs.terraform_action == 'apply' && needs.detect.outputs.has_pp == 'true'
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          URL="https://pp.${ENV}.waooaw.com/health"

          echo "Testing PP health: $URL"
          for i in {1..10}; do
            echo "Attempt $i/10..."
            if curl -f -s -m 10 "$URL" | grep -q "healthy\|ok"; then
              echo "✅ PP health check passed"
              exit 0
            fi
            if [ $i -lt 10 ]; then
              echo "Retrying in 30 seconds..."
              sleep 30
            fi
          done
          echo "::error::PP health check failed after 10 attempts"
          exit 1

      - name: Test Plant health endpoint
        if: inputs.terraform_action == 'apply' && needs.detect.outputs.has_plant == 'true'
        run: |
          set -euo pipefail
          ENV="${{ inputs.environment }}"
          URL="https://plant.${ENV}.waooaw.com/health"

          echo "Testing Plant health: $URL"
          for i in {1..10}; do
            echo "Attempt $i/10..."
            if curl -f -s -m 10 "$URL" | grep -q "healthy\|ok"; then
              echo "✅ Plant health check passed"
              exit 0
            fi
            if [ $i -lt 10 ]; then
              echo "Retrying in 30 seconds..."
              sleep 30
            fi
          done
          echo "::error::Plant health check failed after 10 attempts"
          exit 1

  summary:
    name: Summary
    runs-on: ubuntu-latest
    needs: [resolve, detect, terraform_plan, terraform_apply]
    if: always()

    steps:
      - name: Write summary
        run: |
          echo "Environment: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "Terraform: ${{ inputs.terraform_action }}" >> $GITHUB_STEP_SUMMARY
          echo "Image tag: ${{ needs.resolve.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "Has CP: ${{ needs.detect.outputs.has_cp }}" >> $GITHUB_STEP_SUMMARY
          echo "Has PP: ${{ needs.detect.outputs.has_pp }}" >> $GITHUB_STEP_SUMMARY
          echo "Has Plant: ${{ needs.detect.outputs.has_plant }}" >> $GITHUB_STEP_SUMMARY
